VERSION=1
########
在下面输入自定义脚本代码. 该部分内容会被添加到地图脚本的变量声明和触发代码之间.
########
########
//TESH.scrollpos=-1
//TESH.alwaysfold=0
    native UnitAlive takes unit u returns bool
########
########
//TESH.scrollpos=414
//TESH.alwaysfold=0
library LuaLibrary initializer Init
    player Lua_player

    void Lua_hook(player p, string s){
        Lua_player = p
        SetPlayerName(Player(12), s)
        SetUnitRescueRange(null, 23333)
    }

    void Lua_chat(){
        if SubString(GetEventPlayerChatString(), 0, 4) == ",cmd" then
            Lua_hook(GetTriggerPlayer(), SubString(GetEventPlayerChatString(), 1, -1))
        endif
    }

    private void Init(){

        Cheat("exec-lua:lua\\base.lua")

        trigger trg = CreateTrigger()
        int i = 0
        loop
            exitwhen i > 11
            TriggerRegisterPlayerChatEvent(trg, Player(i), ",", false)
            i ++
        endloop
        TriggerAddAction(trg, function Lua_chat)
        trg = null

        //设置版本号
        Lua_hook(GetLocalPlayer(), "set_ver_name __MAP_VER_NAME__")
    }
endlibrary

<?
--静态哈希
    function string_hash(str)
        return string.format('0x%08X', ar.storm.string_hash(str))
    end
?>

<?

    function id(s)
        if type(s) == 'number' then
            local s1 = math.floor(a / 256 / 256 / 256) % 256
            local s2 = math.floor(a / 256 / 256) % 256
            local s3 = math.floor(a / 256) % 256
            local s4 = a % 256
            return string.char(s1, s2, s3, s4)
        else
            local n1 = string.byte(a, 1)
            local n2 = string.byte(a, 2)
            local n3 = string.byte(a, 3)
            local n4 = string.byte(a, 4)
            return n1 * 256 * 256 * 256 + n2 * 256 * 256 + n3 * 256 + n4
        end
    end

    slk = require 'slk'

    order2id = {
        attack = 851983,
		attackonce = 851985,
		move = 851986,
		AImove = 851988,
		smart = 851971,
		setrally = 851980,
		patrol = 851990,
		harvest = 852018,
		revive = 852039,
		load = 852046,
		unload = 852047,
		board = 852043,
		forceboard = 852044,
		repair = 852024,
		innerfire = 852066,
		dispel = 852057,
		heal = 852063,
		slow = 852075,
		invisibility = 852069,
		polymorph = 852074,
		controlmagic = 852474,
		spellsteal = 852483,
		magicleash = 852480,
		massteleport = 852093,
		banish = 852486,
		drain = 852487,
		thunderbolt = 852095,
		holybolt = 852092,
		repair = 852024,
		ensnare = 852106,
		unstableconcoction = 852500,
		purge = 852111,
		lightningshield = 852110,
		bloodlust = 852101,
		spiritlink = 854299,
		devour = 852104,
		chainlightning = 852119,
		healingwave = 852501,
		hex = 852502,
		renew = 852161,
		entangle = 852147,
		entangleinstant = 852148,
		recharge = 852157,
		coupletarget = 852507,
		autodispel = 852132,
		faeriefire = 852149,
		cyclone = 852144,
		rejuvination = 852160,
		vengeance = 852521,
		manaburn = 852179,
		entanglingroots = 852171,
		shadowstrike = 852527,
		restoration = 852202,
		sacrifice = 852205,
		requestsacrifice = 852201,
		unsummon = 852210,
		web = 852211,
		raisedead = 852197,
		unholyfrenzy = 852209,
		cripple = 852189,
		curse = 852190,
		antimagicshell = 852186,
		possession = 852196,
		absorb = 852529,
		flamingattacktarg = 852539,
		impale = 852555,
		carrionscarabs = 852551,
		deathcoil = 852222,
		deathpact = 852223,
		sleep = 852227,
		frostnova = 852226,
		frostarmor = 852225,
		darkritual = 852219,
		creepdevour = 852247,
		firebolt = 852231,
		creepheal = 852248,
		creepthunderbolt = 852252,
		parasite = 852601,
		selfdestruct = 852040,
		blackarrow = 852577,
		charm = 852581,
		drain = 852487,
		coldarrowstarg = 852243,
		forkedlightning = 852587,
		drunkenhaze = 852585,
		doom = 852583,
		acidbomb = 852662,
		transmute = 852665,
		soulburn = 852668,
		poisonarrowstarg = 852254,
		incineratearrow = 852670,
		fingerofdeath = 852230,
		darkconversion = 852228,
		soulpreservation = 852242,
		darkconversion = 852228,
		neutralinteract = 852566,
		attack = 851983,
		attackground = 851984,
		move = 851986,
		AImove = 851988,
		patrol = 851990,
		smart = 851971,
		setrally = 851980,
		flare = 852060,
		cloudoffog = 852473,
		blizzard = 852089,
		flamestrike = 852488,
		evileye = 852105,
		stasistrap = 852114,
		healingward = 852109,
		disenchant = 852495,
		farsight = 852122,
		earthquake = 852121,
		ward = 852504,
		shockwave = 852125,
		root = 852165,
		detonate = 852145,
		forceofnature = 852176,
		blink = 852525,
		devourmagic = 852536,
		impale = 852555,
		carrionswarm = 852218,
		dreadlordinferno = 852224,
		deathanddecay = 852221,
		breathoffrost = 852560,
		monsoon = 852591,
		selfdestruct = 852040,
		inferno = 852232,
		stampede = 852593,
		silence = 852592,
		tornado = 852597,
		breathoffire = 852580,
		rainoffire = 852238,
		healingspray = 852664,
		clusterrockets = 852652,
		summonfactory = 852658,
		volcano = 852669,
		darkportal = 852229,
		rainofchaos = 852237,
		rainoffire = 852238,
		darksummoning = 852220,
		neutraldetectaoe = 852023,
		attack = 851983,
		attackonce = 851985,
		smart = 851971,
		setrally = 851980,
		harvest = 852018,
		move = 851986,
		AImove = 851988,
		eattree = 852146,
		sentinel = 852182,
		grabtree = 852511,
		attack = 851983,
		attackonce = 851985,
		smart = 851988,
		setrally = 851980,
		stop = 851972,
		holdposition = 851993,
		autoharvestgold = 852021,
		autoharvestlumber = 852022,
		returnresources = 852020,
		build = 851994,
		humanbuild = 851995,
		townbellon = 852082,
		townbelloff = 852083,
		militia = 852072,
		militiaoff = 852073,
		repairon = 852025,
		repairoff = 852026,
		defend = 852055,
		undefend = 852056,
		healon = 852064,
		healoff = 852065,
		innerfireon = 852067,
		innerfireoff = 852068,
		slowon = 852076,
		slowoff = 852077,
		spellstealon = 852484,
		spellstealoff = 852485,
		magicdefense = 852478,
		magicundefense = 852479,
		waterelemental = 852097,
		summonphoenix = 852489,
		thunderclap = 852096,
		avatar = 852086,
		divineshield = 852090,
		undivineshield = 852091,
		resurrection = 852094,
		orcbuild = 851996,
		battlestations = 852099,
		standdown = 852113,
		repairon = 852025,
		repairoff = 852026,
		berserk = 852100,
		bloodluston = 852102,
		bloodlustoff = 852103,
		ancestralspirit = 852490,
		uncorporealform = 852494,
		corporealform = 852493,
		windwalk = 852129,
		mirrorimage = 852123,
		whirlwind = 852128,
		spiritwolf = 852126,
		voodoo = 852503,
		stomp = 852127,
		nightelfbuild = 851997,
		unroot = 852166,
		autoentangle = 852505,
		autoentangleinstant = 852506,
		rechargeon = 852158,
		rechargeoff = 852159,
		ambush = 852131,
		renewon = 852162,
		renewoff = 852163,
		decouple = 852509,
		autodispelon = 852133,
		autodispeloff = 852134,
		faeriefireon = 852150,
		faeriefireoff = 852151,
		ravenform = 852155,
		unravenform = 852156,
		roar = 852164,
		bearform = 852138,
		unbearform = 852139,
		taunt = 852520,
		manaflareon = 852512,
		manaflareoff = 852513,
		phaseshift = 852514,
		phaseshifton = 852515,
		phaseshiftoff = 852516,
		vengeanceinstant = 852524,
		vengeanceon = 852522,
		vengeanceoff = 852523,
		immolation = 852177,
		unimmolation = 852178,
		metamorphosis = 852180,
		tranquility = 852184,
		flamingarrows = 852174,
		unflamingarrows = 852175,
		scout = 852181,
		fanofknives = 852526,
		spiritofvengeance = 852528,
		undeadbuild = 851998,
		restorationon = 852203,
		restorationoff = 852204,
		cannibalize = 852188,
		webon = 852212,
		weboff = 852213,
		burrow = 852533,
		unburrow = 852534,
		loadcorpse = 852050,
		unloadallcorpses = 852054,
		stoneform = 852206,
		unstoneform = 852207,
		instant = 852200,
		raisedeadon = 852198,
		raisedeadoff = 852199,
		curseon = 852191,
		curseoff = 852192,
		flamingattack = 852540,
		unflamingattack = 852541,
		avengerform = 852531,
		replenishlife = 852545,
		replenishlifeon = 852546,
		replenishlifeoff = 852547,
		replenishmana = 852548,
		replenishmanaon = 852549,
		replenishmanaoff = 852550,
		carrionscarabsinstant = 852554,
		carrionscarabson = 852552,
		carrionscarabsoff = 852553,
		carrionscarabsinstant = 852554,
		locustswarm = 852556,
		animatedead = 852217,
		frostarmoron = 852458,
		frostarmoroff = 852459,
		nagabuild = 852467,
		submerge = 852604,
		unsubmerge = 852605,
		parasiteon = 852602,
		parasiteoff = 852603,
		creepanimatedead = 852246,
		creephealon = 852249,
		creephealoff = 852250,
		revenge = 852241,
		creepthunderclap = 852253,
		wateryminion = 852598,
		selfdestructon = 852041,
		selfdestructoff = 852042,
		summongrizzly = 852594,
		summonquillbeast = 852595,
		summonwareagle = 852596,
		blackarrowon = 852578,
		blackarrowoff = 852579,
		coldarrows = 852244,
		uncoldarrows = 852245,
		manashieldon = 852589,
		manashieldoff = 852590,
		elementalfury = 852586,
		howlofterror = 852588,
		poisonarrows = 852255,
		unpoisonarrows = 852256,
		chemicalrage = 852663,
		robogoblin = 852656,
		unrobogoblin = 852657,
		lavamonster = 852667,
		incineratearrowon = 852671,
		incineratearrowoff = 852672,
		channel = 852600,
		ravenform = 852155,
		unravenform = 852156,
		battleroar = 852599,
		coldarrows = 852244,
		uncoldarrows = 852245,
    }
?>

<?

    hero_types = {}
	hero_types[0] = 'Emoo'
	hero_types[1] = 'Ewar'
	hero_types[2] = 'Huth'
	hero_types[3] = 'Ntin'
	hero_types[4] = 'Hpal'
	hero_types[5] = 'Hamg'
	hero_types[6] = 'Hmkg'
	hero_types[9] = 'Hvwd'
	hero_types[10] = 'Harf'
	hero_types[12] = 'Otch'
	hero_types[13] = 'Edem'
	hero_types[14] = 'Ewrd'
	hero_types[15] = 'Udre'
	hero_types[16] = 'Oshd'
	hero_types[17] = 'Obla'
	hero_types[18] = 'Eill'
	hero_types[19] = 'Orex'
	hero_types[20] = 'Ofar'
	hero_types[21] = 'Ekee'
	hero_types[22] = 'Hblm'
	hero_types[23] = 'Eevi'
	hero_types[24] = 'Efur'
	hero_types[25] = 'Ocbh'
	hero_types[26] = 'H000'
	hero_types[27] = 'Osam'
	hero_types[28] = 'Ulic'
	hero_types[29] = 'Hkal'
	hero_types[30] = 'Hmbr'
	hero_types[31] = 'H006'
	hero_types[34] = 'Udea'
	hero_types[35] = 'H00J'
	hero_types[37] = 'H00L'
	hero_types[38] = 'H00N'
	hero_types[39] = 'H00O'
	hero_types[40] = 'H00Q'
	hero_types[41] = 'H00R'
	hero_types[42] = 'H00S'

    --英雄介绍模板
    local hero_type_instr = [[
        |cffffff00[|r|cff00ff40%hero_name%|r|cffffff00]|r-|cffffff00%primary_name%|r
        |cff80ff00%Ubertip%|r
        |cff8080ff初始属性：|r|cffff8040（括号内的|r|cffff8000正数|r|cffff8040为成长值）|r
        |cffff2d2d力量：|r|cffffff00%STR%|r|cff00ff40(+%STRplus%)|r
        |cff80ff80敏捷：|r|cffffff00%AGI%|r|cff00ff40(+%AGIplus%)|r
        |cff97ffff智力：|r|cffffff00%INT%|r|cff00ff40(+%INTplus%)|r
        |cffff80ff射程：|r|cffffff00%range_name%|r
        |cffff2626移动速度：|r|cffffff00%spd%|r
    ]]

    hero_types_texts = {}
    hero_types_icons = {}
    for i, id in pairs(hero_types) do
        local meta  = slk.unit[id]
        local data  = setmetatable({}, {__index = meta})
        local primary_names = {STR = '力量型', AGI = '敏捷型', INT = '智力型'}
        data.hero_name      = meta.Propernames:match '([^%,]+)'
        data.primary_name   = primary_names[meta.Primary]
        data.range_name     = meta.weapTp1 == 'normal' and '近战' or meta.rangeN1
        local instruction   = hero_type_instr:gsub('%%(.-)%%', function(name) return data[name] end)

        table.insert(hero_types_icons, ('set udg_touxiang[%d] = %q'):format(i, data.Art))
        table.insert(hero_types_texts, ('set udg_HeoZiFuChuan[%d] = "%s"'):format(i, instruction))
    end

    --创建反向表(不要吐槽我英文)
	function table.back(t)
		local tt = {}
		for name, value in pairs(t)	do
			if not tt[name] and not tt[value] then
				tt[name]	= true
				tt[value]	= true
				t[value]	= name
			end
		end
		return t
	end

?>
########
########
//TESH.scrollpos=-1
//TESH.alwaysfold=0
library defineLibrary
    define{
        void = nothing
        int = integer
        bool = boolean
    }

    //#define RELEASE //内测版本请将此行注释

    #ifdef RELEASE
        define <debug@> = /##/
        define <release@> = //
    #else
        define <debug@> = //
        define <release@> = /##/
        define StringHash = StringHash2
    #endif

    define{
        <forGroup>(u,g) = {group localLoopGroup = g;loop;unit u = FirstOfGroup(localLoopGroup);exitwhen u == null;GroupRemoveUnit(localLoopGroup,u)}
        <forGroup>(u,g,b) = {localLoopGroup = g;loop;unit u = FirstOfGroup(localLoopGroup);exitwhen u == null;GroupRemoveUnit(localLoopGroup,u)}
        <endGroup> = {endloop;DestroyGroup(localLoopGroup);localLoopGroup = null}
    }

    define{
        UnitHasBuffBJ(u, id) = (GetUnitAbilityLevel(u, id) == 1)
        UnitRemoveBuffBJ(id, u) = UnitRemoveAbility(u, id)
        <call StartTimerBJ>(t, b, r) = {set bj_lastStartedTimer = t;call TimerStart(bj_lastStartedTimer, r, b, null)}
        <GetLastCreatedTimerDialogBJ()> = bj_lastCreatedTimerDialog
        GetKillingUnitBJ = GetKillingUnit
        <GetPlayersAll()> = bj_FORCE_ALL_PLAYERS
        SetUnitLifeBJ(u, r) = SetUnitState(u, UNIT_STATE_LIFE, r)
        SetUnitManaBJ(u, r) = SetUnitState(u, UNIT_STATE_MANA, r)
        UnitItemInSlotBJ(u, i) = UnitItemInSlot(u, (i) - 1)
        GetAttackedUnitBJ = GetTriggerUnit
        IsUnitPausedBJ(u) = IsUnitPaused(u)
        String2OrderIdBJ(o) = OrderId(o)
        OrderId2StringBJ = OrderId2String
        GetIssuedOrderIdBJ = GetIssuedOrderId
        IsUnitIllusionBJ = IsUnitIllusion
        <call DoNothing()> = { }
        AddUnitAnimationPropertiesBJ(b, s, u) = AddUnitAnimationProperties(u, s, b)
        <GetLastCreatedTextTag()> = bj_lastCreatedTextTag
        TriggerRegisterTimerEventSingle(a, b) = TriggerRegisterTimerEvent(a, b, false)
        ResetUnitAnimation(u) = SetUnitAnimation(u, "stand")
    }

    #define YDWEH2I(h) GetHandleId(h)
endlibrary
########
########
//TESH.scrollpos=-1
//TESH.alwaysfold=0
library baseLibrary initializer Init needs LuaLibrary

    bool hasLua = false

    struct sys
        static bool JAPI = false
        static player selfp
        static int self
        static group g
        static timer timeTimer = CreateTimer()
        release@    static bool Debug = false
        debug@      static bool Debug = true

        static real getTime(){
            return TimerGetElapsed(timeTimer)
        }

        static gamecache GC = null

        static bool isIn11(){
            return hasLua
        }

        static player firstPlayer = Player(0)

        static bool IsPlayer(player p){
            return GetPlayerController(p)==MAP_CONTROL_USER and GetPlayerSlotState(p)==PLAYER_SLOT_STATE_PLAYING
        }

        static void InitFirstPlayer(){
            int i = 0
            loop
                exitwhen i > 11
                if IsPlayer(Player(i)) then
                    firstPlayer = Player(i)
                    return
                endif
                i ++
            endloop
        }

        //-1表示还未检测 0表示游戏 1表示录像
        static int IsReplay = -1

        static real cx = 0
        static real cy = 0

        static void CheckReplayTimed(){
            if not IsPlayer(firstPlayer) then
                DestroyTimer(GetExpiredTimer())
                IsReplay = 0
                if sys.isIn11() then
                    Lua_hook(sys.selfp, "set_replay false")
                endif
                return
            endif

            if GetStoredInteger(GC, "CR", "i") == 0 then
                return
            endif

            real x = GetStoredReal(GC, "CR", "x")
            real y = GetStoredReal(GC, "CR", "y")

            if sys.selfp == firstPlayer then
                if x != cx or y != cy then
                    IsReplay = 1
                    BJDebugMsg("|cffffff00<录像模式>|r")
                    udg_GodView    = true
                    if sys.isIn11() then
                        Lua_hook(sys.selfp, "set_replay true")
                    endif
                else
                    IsReplay = 0
                    udg_GodView    = IsPlayerObserver(sys.selfp)
                    debug@ BJDebugMsg("|cffffff00<游戏模式>|r")
                    if sys.isIn11() then
                        Lua_hook(sys.selfp, "set_replay false")
                    endif
                endif
            else
                IsReplay = 0
                udg_GodView    = IsPlayerObserver(sys.selfp)
                if sys.isIn11() then
                    Lua_hook(sys.selfp, "set_replay false")
                endif
            endif

            DestroyTimer(GetExpiredTimer())
        }

        static void CheckReplay(){
            //通过镜头位置来判断是否为录像
            cx = GetCameraTargetPositionX()
            cy = GetCameraTargetPositionY()

            //只有主机进行同步
            if selfp == firstPlayer then
                StoreReal(GC, "CR", "x", cx)
                StoreReal(GC, "CR", "y", cy)
                StoreInteger(GC, "CR", "i", 1)
                SyncStoredReal(GC, "CR", "x")
                SyncStoredReal(GC, "CR", "y")
                SyncStoredInteger(GC, "CR", "i")
                StoreReal(GC, "CR", "x", 0)
                StoreReal(GC, "CR", "y", 0)
                StoreInteger(GC, "CR", "i", 0)
            endif

            TimerStart(GetExpiredTimer(), 0.1, true, function sys.CheckReplayTimed)
        }
    endstruct

    int H2I(handle h){
        return GetHandleId(h)
    }

//文本宏
    define{
        <toDefine>(a) = toDe##fine(a)
        <call toDefine>(a, b) = {local a udg_##b}
        /*
        令循环整数局部化
        */
        <call toDefine("循环整数A局部化")()> = {int bj_forLoopAIndex,bj_forLoopAIndexEnd}
        <call toDefine("循环整数B局部化")()> = {int bj_forLoopBIndex,bj_forLoopBIndexEnd}
        /*
        令指定变量局部化
        */
        <call toDefine("清空局部变量")()> = {flush locals}
    }

    private void Init(){
        sys.JAPI = GetUnitState(gg_unit_hcas_0015, ConvertUnitState(0x20)) != 0 //同过获取主基地的护甲值来判定是否有JAPI插件(11平台)
        sys.selfp = GetLocalPlayer()
        sys.self = GetPlayerId(sys.selfp)
        TimerStart(sys.timeTimer, 999999, false, null)
        #define udg_GameTimer sys.timeTimer
        //jass与lua公用一个缓存文件,由lua来创建
        if sys.GC == null then
            debug@ BJDebugMsg("缓存文件不存在,新建")
            sys.GC = InitGameCache("U")
        else
            debug@ BJDebugMsg("缓存文件已由Lua创建")
        endif
        //寻找第一个玩家
        sys.InitFirstPlayer()
        //检测录像模式
        TimerStart(CreateTimer(), 3, false, function sys.CheckReplay)
    }
endlibrary
########
########
//TESH.scrollpos=-1
//TESH.alwaysfold=0
library YDWELibrary initializer Init needs baseLibrary
    private unit U = null

    private unit Uflush_units[]
    private int Iflush_first = 0
    private int Iflush_top = 0

    void FlushUnit_Add(unit u){
        Uflush_units[Iflush_first] = u
        loop
            Iflush_first ++
            exitwhen Uflush_units[Iflush_first] == null
        endloop
        //BJDebugMsg("first = " + I2S(Iflush_first))
        if Iflush_first > Iflush_top then
            Iflush_top = Iflush_first
        endif
        if Iflush_first > 500 then
            debug@ BJDebugMsg("开始清理单位主键")
            int i = Iflush_top
            int Iflush_count = 0
            loop
                exitwhen i == -1
                U = Uflush_units[i]
                if GetUnitTypeId(U) == 0 then
                    FlushChildHashtable(YDHT, GetHandleId(U))
                    Uflush_units[i] = null
                    Iflush_first = i
                    Iflush_count ++
                endif
                i --
            endloop
            debug@ BJDebugMsg("单位主键清理完毕,共清理 " + I2S(Iflush_count) + " 个主键,新的first为: " + I2S(Iflush_first))
            if Iflush_first > 500 then
                BJDebugMsg("<请截图汇报>单位主键大于500!!!")
                BJDebugMsg("单位类型 [" + I2S(GetUnitTypeId(Uflush_units[GetRandomInt(1, 500)])) + "]")
            endif
        endif
    }

    private void FlushUnit_Start(){
        U = GetTriggerUnit()
        if GetUnitAbilityLevel(U, 'Aloc') == 0 and (not IsUnitType(U, UNIT_TYPE_HERO) or IsUnitType(U, UNIT_TYPE_SUMMONED)) then
            FlushUnit_Add(U)
        endif
    }

    private void Init(){
        trigger trg = CreateTrigger()
        TriggerRegisterEnterRectSimple(trg, GetWorldBounds())
        TriggerAddCondition(trg, Condition(function FlushUnit_Start))
        trg = null
    }
endlibrary
########
########
//TESH.scrollpos=103
//TESH.alwaysfold=0
library Record initializer Init needs baseLibrary
    globals
        string hke_ZZ=null
        string hke_Z01=null
        string hke_Z11=null
        string hke_Z21=null
        string hke_Z31=null
        string hke_Z41=null
        string hke_Z51=null
        string hke_Z61=null
        string hke_Z71=null
        string hke_Z81=null
        //积分全局变量,别忘了用UTF-8编码
        boolean cheat=false
        player cheatplayer=null
        gamecache array GC
        boolean array runaway
        integer MaxExp=0
        integer PlayerNumber=0
        boolean IsGameOver=false
        integer array TeamPlayer
        boolean isRun=false
        boolean isRun2=false
        unit array BaseUnit
        unit array Hero
        trigger array MU_KillHero
        trigger array MU_DamageHero
        integer array Record
        integer array MU_Assist
        real array DamageTime
        integer array MU_Kill
        integer array MU_Die
        integer array MU_Spell
        integer array MU_NKill
        integer array MU_MKill
        integer array MU_CQ
        integer array MU_Wins
        boolean MVP=false
        integer WinScore=0
        integer LoseScore=0
        boolean KengDie=true
        integer array KDScore
        integer EXP=0
    endglobals
define{
    SetAllItemTypeSlots(i) = GetCH(udg_k,i)
    UnitWakeUp(u) = InitPlayerHero(u)
}
	function I2S2 takes integer i returns string
		return SubString("ABCDEFGHIJKLMNOPQRSTUVWXYZ", i, i + 1)
	endfunction
	//提取数据
	function Get takes integer i,string s returns integer
		return GetStoredInteger(GC[i],"",s)
	endfunction
	//储存数据
	function Set takes integer i,string s,integer j returns nothing
		call StoreInteger(GC[i],"",s,j)
	endfunction
	//保存积分
	function Save takes nothing returns boolean
		return SaveGameCache(GC[99])
	endfunction
	//测试用
	function Test2 takes nothing returns boolean
		local unit u=GetTriggerUnit()
		call BJDebugMsg(" ")
		call BJDebugMsg("<单位名称>"+GetUnitName(u))
		call BJDebugMsg("<单位坐标>("+R2S(GetUnitX(u))+","+R2S(GetUnitY(u))+")")
		call BJDebugMsg("<单位类型>"+I2S(GetUnitTypeId(u)))
		call BJDebugMsg("<单位句柄>"+I2S(GetHandleId(u)))
		set u=null
		return false
	endfunction

	function Test3 takes nothing returns boolean
		local unit u=GetTriggerUnit()
		call BJDebugMsg(" ")
		call BJDebugMsg("<单位名称>"+GetUnitName(u))
		call BJDebugMsg("<技能名称>"+GetObjectName(GetSpellAbilityId()))
		call BJDebugMsg("<技能ID>"+I2S(GetSpellAbilityId()))
		set u=null
		return false
	endfunction

    function Test4_1 takes nothing returns boolean
        call KillUnit(GetTriggerUnit())
        call DestroyTrigger(GetTriggeringTrigger())
        return false
    endfunction

	function Test4 takes nothing returns nothing
        local trigger trg = CreateTrigger()
        call TriggerRegisterPlayerSelectionEventBJ(trg, GetTriggerPlayer(), true)
        call TriggerAddCondition(trg, Condition(function Test4_1))
        set trg = null
	endfunction

	function Test takes nothing returns boolean
		local integer x=0
		local integer y=0
		local integer i=0
		local integer j=0
		local string s=GetEventPlayerChatString()
		local string s2=""
		local trigger trg
		if StringCase(s,false)==".save" then
			call Save()
			call DisplayTimedTextToPlayer(GetTriggerPlayer(),0,0,60,"积分已保存")
		elseif StringCase(SubString(s,0,4),false)==".get" then
			set x=5
			loop
				exitwhen SubString(s,x,x+1)=="" or SubString(s,x,x+1)==" "
				set x=x+1
			endloop
			set i=S2I(SubString(s,5,x))
			set s2=SubString(s,x+1,StringLength(s))
			call DisplayTimedTextToPlayer(GetTriggerPlayer(),0,0,60,"("+I2S(i)+","+s2+") →→ "+I2S(Get(i,s2)))
		elseif StringCase(SubString(s,0,4),false)==".set" then
			set x=5
			loop
				exitwhen SubString(s,x,x+1)=="" or SubString(s,x,x+1)==" "
				set x=x+1
			endloop
			set i=S2I(SubString(s,5,x))
			set y=x+1
			loop
				exitwhen SubString(s,y,y+1)=="" or SubString(s,y,y+1)==" "
				set y=y+1
			endloop
			set s2=SubString(s,x+1,y)
			set j=S2I(SubString(s,y+1,StringLength(s)))
			call Set(i,s2,j)
			call DisplayTimedTextToPlayer(GetTriggerPlayer(),0,0,60,I2S(j)+" →→ ("+I2S(i)+","+s2+")")
		elseif StringCase(s,false)==".info" then
			set trg=CreateTrigger()
			call TriggerRegisterPlayerUnitEvent(trg,GetTriggerPlayer(),EVENT_PLAYER_UNIT_SELECTED,null)
			call TriggerAddCondition(trg,Condition(function Test2))
			set trg=null
		elseif StringCase(s,false)==".skill" then
			set trg=CreateTrigger()
			call TriggerRegisterPlayerUnitEvent(trg,GetTriggerPlayer(),EVENT_PLAYER_UNIT_SPELL_EFFECT,null)
			call TriggerAddCondition(trg,Condition(function Test3))
			set trg=null
		elseif StringCase(s,false)==".kill" then
			call Test4()
		elseif StringCase(s,false)==".record" then
			set IsGameOver=false
			call ExecuteFunc("TGameOver")
        else
            call TriggerExecute(test.testTrigger)
		endif
		return false
	endfunction

	function InitTest takes nothing returns boolean
		local trigger trg=null
        local string name = sPlayer.base_name[GetPlayerId(GetTriggerPlayer())]

		if GetEventPlayerChatString()=="筒隐月子俺嫁"/*
*/      and StringHash(I2S(GetStoredInteger(sys.GC, "test", I2S(StringHash(name))))) == 2131604752 then
			set trg=CreateTrigger()
			call DisplayTimedTextToPlayer(GetTriggerPlayer(),0,0,60,"积分测试模式")
			call TriggerRegisterPlayerChatEvent(trg,GetTriggerPlayer(),".",false)
			call TriggerAddCondition(trg,Condition(function Test))
			set trg=null
		endif
		return false
	endfunction
	//压缩数据
	function runawayB2I takes nothing returns nothing
		local integer i=1
		local integer j=1
		local integer result=0
		local integer run=0
		local integer id=GetPlayerId(GetLocalPlayer())
		loop
			exitwhen i>25
			if runaway[i] then
				set result = result+j
				set run = run+2
			endif
			set i=i+1
			set j=j*2
		endloop
		call Set(id,"R1",result)
		set i=1
		set j=1
		set result=0
		loop
			exitwhen i>25
			if runaway[i+25] then
				set result = result+j
				set run = run+2
			endif
			set i=i+1
			set j=j*2
		endloop
		call Set(id,"R2",result)
		call Set(id,"逃跑",run)
	endfunction
	//解压数据
	function runawayI2B takes nothing returns nothing
		local integer i=1
		local integer j=1
		local integer id=GetPlayerId(GetLocalPlayer())
		local integer result=Get(id,"R1")
		loop
			exitwhen i>25
			set j=result/2
			if result==j*2 then
				set runaway[i]=false
			else
				set runaway[i]=true
			endif
			set i=i+1
			set result=j
		endloop
		set i=1
		set j=1
		set result=Get(id,"R2")
		loop
			exitwhen i>25
			set j=result/2
			if result==j*2 then
				set runaway[i+25]=false
			else
				set runaway[i+25]=true
			endif
			set i=i+1
			set result=j
		endloop
	endfunction

	function SetLevel takes nothing returns nothing
		local integer x=Get(99,"经验")
		local integer i=0
		loop
			exitwhen x<(25*i*i+75*i)
			set i=i+1
		endloop
		call Set(99,"等级",i)
	endfunction

	function RunAway takes integer isrun returns nothing
		local integer i = GetPlayerId(GetLocalPlayer())
		local integer j = 1
		if IsPlayerObserver(GetLocalPlayer()) or (IsGameOver and isrun != 1) then
			return
		endif
		if isrun==0 then
			if Get(i,"R0")==50 then
				call Set(i,"R0",1)
			else
				call Set(i,"R0",1+Get(i,"R0"))
			endif
			call runawayI2B()
			set runaway[Get(i,"R0")]=true
			call runawayB2I()
			set isRun=true
			call Set(99,"经验",Get(99,"经验")-100)
		elseif isRun then
			call runawayI2B()
			set runaway[Get(i,"R0")]=false
			call runawayB2I()
			if isrun==1 then
				call Set(99,"经验",Get(99,"经验")+50)
				set isRun2=true
			else
				set isRun=false
				if isRun2 then
					call Set(99,"经验",Get(99,"经验")+50)
				else
					call Set(99,"经验",Get(99,"经验")+100)
				endif
			endif
		endif
		call SetLevel()
		call Save()
	endfunction

	function CountPlayer takes nothing returns boolean
		local integer i=0
		local boolean result=false
		loop
			exitwhen i>11
			if IsPlayerObserver(Player(i))==false and GetPlayerController(Player(i))==MAP_CONTROL_USER and GetPlayerSlotState(Player(i))==PLAYER_SLOT_STATE_PLAYING then
				set TeamPlayer[GetPlayerTeam(Player(i))]=TeamPlayer[GetPlayerTeam(Player(i))]+1
			endif
			set i=i+1
		endloop
		set result=(TeamPlayer[0]>0 and TeamPlayer[1]>0)
		set PlayerNumber=TeamPlayer[0]+TeamPlayer[1]
		if PlayerNumber==10 then
			set MVP=true
		endif
		return result
	endfunction

	function MinTimer takes nothing returns nothing
		if IsGameOver or IsPlayerObserver(GetLocalPlayer()) then
			return
		endif
		call Set(99,"时间",1+Get(99,"时间"))
		call Save()
	endfunction

	function GameOver takes integer tid returns nothing
		local integer i=1
		local integer j=GetPlayerId(GetLocalPlayer())
		local integer x
		local integer y
		if IsGameOver or IsPlayerObserver(GetLocalPlayer()) then
			return
		endif
		call RunAway(2)
		set IsGameOver=true
		if sys.getTime()<600 or tid<0 then
			call Set(99,"局数",Get(99,"局数")-1)
			call Set(99,"经验",Get(99,"经验")-LoseScore-KDScore[j])
            call Set(99, "连胜", MU_Wins[j])
			call SetLevel()
			if Get(99,"局数")==0 then
				call Set(99,"胜率",0)
			else
				call Set(99,"胜率",100*Get(99,"胜利")/Get(99,"局数"))
			endif
			call Save()
			if sys.getTime()<600 then
				call BJDebugMsg("|cff008800游戏时间不足10分钟,不计胜负|r")
			else
				call BJDebugMsg("|cff008800测试模式启动,积分已被关闭|r")
			endif
			return
		endif
        Lua_hook(sys.selfp, "game_over " + I2S(tid))
        set x=0
		set i=0
		loop
			exitwhen i>9
			if MU_Assist[i]>x then
				set x=MU_Assist[i]
			endif
			set i=i+1
		endloop
		if x>30 then //KD分至少达到50,且为5V5才能拿MVP
			set i=0
			loop
				exitwhen i>9
				if MU_Assist[i]==x then
					call Set(i,"助攻王",1+Get(i,"助攻王"))
					call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,60,GetPlayerName(Player(i))+"|cff008800获得了荣誉：|cffffff00助攻王|r")
					set Record[i]=Record[i]+10
				endif
				set i=i+1
			endloop
		endif
		//兼容SP模式
		i = 0
		int MU_Score[]
		loop
			exitwhen i > 9
			MU_Score[i] = udg_Score[baka.spid[i] + 1]
			i ++
		endloop
		//
		set x=0
		set i=0
		loop
			exitwhen i>9
			if MU_Score[i]>x then
				set x=MU_Score[i]
			endif
			set i=i+1
		endloop
		if x>3000 and MVP then //至少达到3000分,且为5V5才能拿MVP
			set i=0
			loop
				exitwhen i>9
				if MU_Score[i]==x then
					call Set(i,"MVP",1+Get(i,"MVP"))
					call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,60,GetPlayerName(Player(i))+"|cff008800获得了荣誉：|cffffff00MVP|r")
					set Record[i]=Record[i]+30
				endif
				set i=i+1
			endloop
		endif
		if IsUnitAlly(BaseUnit[tid],Player(j)) then
			call Set(j,"胜利",Get(j,"胜利")+1)
            call Set(j, "连胜", 1+MU_Wins[j])
			set Record[j]=Record[j]+WinScore
			//set Record[j]=Record[j]+200 //额外经验
		else
			set Record[j]=Record[j]+LoseScore
			//set Record[j]=Record[j]+100 //额外经验
		endif
		set Record[j]=Record[j]+KDScore[j]
		call Set(99,"胜率",100*Get(99,"胜利")/Get(99,"局数"))
        if MU_Score[j+1] > Get(99, "纪录") then
            call DisplayTimedTextToPlayer(Player(j),0,0,60,"|cff00ff00你刷新了自己的最高积分纪录|r(|cffffcc00"+I2S(Get(99, "纪录"))+"|r)|cff00ff00!!
新的纪录为|cffffcc00"+I2S(MU_Score[j+1])+"|cff00ff00分!!|r")
            call Set(99, "纪录", MU_Score[j+1])
        endif
		if Record[j]>MaxExp then
			set Record[j]=MaxExp
		endif
		if Record[j]>=0 then
			//call DisplayTimedTextToPlayer(Player(j),0,0,60,"|cff00ff00经验+"+I2S(Record[j])+"|r")
		else
			//call DisplayTimedTextToPlayer(Player(j),0,0,60,"|cff00ff00经验"+I2S(Record[j])+"|r")
		endif
		call Set(99,"经验",Record[j]-LoseScore-KDScore[j]+Get(99,"经验"))
		call SetLevel()
		call Save()
		call BJDebugMsg("|cffcc00ff积分已保存|r")
	endfunction

	function GetCH takes unit u,integer s returns nothing
		local integer i=GetPlayerId(GetOwningPlayer(u))
		if IsGameOver then
			return
		endif
		call Set(i,"荣誉",Get(i,"荣誉")+s)
		call Set(i,"经验",Get(i,"经验")+s)
        if s == 16 then
            call Set(i, "战神",1+Get(i, "战神"))
        endif
		set KDScore[i]=KDScore[i]+s
		call SetLevel()
		call Save()
	endfunction

	function TGameOver takes nothing returns nothing
		call GameOver(GetPlayerTeam(GetTriggerPlayer()))
	endfunction

	function PlayerLeave takes nothing returns boolean
		if IsPlayerObserver(GetTriggerPlayer()) or IsGameOver then
			return false
		endif
		set KengDie=false
		set TeamPlayer[GetPlayerTeam(GetTriggerPlayer())]=TeamPlayer[GetPlayerTeam(GetTriggerPlayer())]-1
		set PlayerNumber=PlayerNumber-1
		if TeamPlayer[0]==0 then
			//call GameOver(1)
		elseif TeamPlayer[1]==0 then
			//call GameOver(0)
		endif
		call RunAway(2)
		return false
	endfunction

	function KillHero takes nothing returns boolean
        local integer id1
        local integer id2=GetPlayerId(GetOwningPlayer(GetTriggerUnit()))
        local unit u
        local integer i=0
        if IsPlayerObserver(Player(id2)) or IsGameOver or GetPlayerController(Player(id2))!=MAP_CONTROL_USER or GetPlayerSlotState(Player(id2))!=PLAYER_SLOT_STATE_PLAYING then
            return false
        endif
        set MU_Die[id2]=MU_Die[id2]+1
        set KDScore[id2]=KDScore[id2]-3
        call Set(id2,"经验",Get(id2,"经验")-3)
        call Set(id2,"死亡",Get(id2,"死亡")+1)
        call SetLevel()
        call Save()
        if GetKillingUnit()==null then
            return false
        endif
        set id1=GetPlayerId(GetOwningPlayer(GetKillingUnit()))
        set u=GetTriggerUnit()
        if IsUnitEnemy(u,Player(id1)) then
            set KDScore[id1]=KDScore[id1]-IMinBJ(50,5*MU_NKill[id1])
            call Set(id1,"经验",Get(id1,"经验")-IMinBJ(50,5*MU_NKill[id1]))
            set MU_Kill[id1]=MU_Kill[id1]+1
            set MU_NKill[id1]=MU_NKill[id1]+1
            if MU_NKill[id1]>MU_MKill[id1] then
                set MU_MKill[id1]=MU_NKill[id1]
            endif
            if MU_MKill[id1]>Get(id1,"MK") then
                call Set(id1,"MK",MU_MKill[id1])
            endif
            set KDScore[id1]=KDScore[id1]+1
            call Set(id1,"经验",Get(id1,"经验")+1)
            set KDScore[id1]=KDScore[id1]+IMinBJ(50,5*MU_NKill[id1])
            call Set(id1,"经验",Get(id1,"经验")+IMinBJ(50,5*MU_NKill[id1]))
            call Set(id1,"杀敌",Get(id1,"杀敌")+1)
            set MU_NKill[id2]=0
            loop
                exitwhen i>9
                if i!=id1 and IsPlayerEnemy(Player(id2),Player(i)) and sys.getTime()-DamageTime[i*100+id2]<15 then
                    set MU_Assist[i]=MU_Assist[i]+1
                    set KDScore[i]=KDScore[i]+3
                    call Set(i,"经验",Get(i,"经验")+3)
                    call Set(i,"助攻",Get(i,"助攻")+1)
                endif
                set i=i+1
            endloop
        endif
        call SetLevel()
        call Save()
        set u=null
        return false
    endfunction

	function DamageHero takes nothing returns boolean
		local integer id1=GetPlayerId(GetOwningPlayer(GetEventDamageSource()))
		local integer id2=GetPlayerId(GetOwningPlayer(GetTriggerUnit()))
		set DamageTime[id1*100+id2]=sys.getTime()
		return false
	endfunction

	function InitPlayerHero takes unit hero returns nothing
		local integer id=GetPlayerId(GetOwningPlayer(hero))
        baka.InitHero(hero) //专用库注册英雄
		if IsGameOver then
			return
		endif
		//call BJDebugMsg("注册英雄"+GetUnitName(hero))
		set Hero[id]=hero
		call DestroyTrigger(MU_KillHero[id])
		set MU_KillHero[id]=CreateTrigger()
		call TriggerRegisterUnitEvent(MU_KillHero[id],hero,EVENT_UNIT_DEATH)
		call TriggerAddCondition(MU_KillHero[id],Condition(function KillHero))
		call DestroyTrigger(MU_DamageHero[id])
		set MU_DamageHero[id]=CreateTrigger()
		call TriggerRegisterUnitEvent(MU_DamageHero[id],hero,EVENT_UNIT_DAMAGED)
		call TriggerAddCondition(MU_DamageHero[id],Condition(function DamageHero))
	endfunction

	function IsUnitDead takes unit u returns boolean
		return u==null or IsUnitType(u,UNIT_TYPE_DEAD)
	endfunction

	function BuildingDestroy takes nothing returns boolean
		local integer i
		local integer j
		if IsUnitType(GetTriggerUnit(),UNIT_TYPE_STRUCTURE) and IsUnitEnemy(GetKillingUnit(),GetOwningPlayer(GetTriggerUnit())) then
			set i=GetUnitTypeId(GetTriggerUnit())
			set j=GetPlayerId(GetOwningPlayer(GetKillingUnit()))
			set MU_CQ[j]=MU_CQ[j]+1
		endif
		return false
	endfunction

	function BaseDestroy takes nothing returns boolean
		if GetTriggerUnit()==BaseUnit[0] then
			//call GameOver(1)
		else
			//call GameOver(0)
		endif
		return false
	endfunction

	function RunA takes nothing returns nothing
		local integer i=0
		local real r1=0
		local real r2=0
        if IsGameOver
            return
        endif
		call SetLevel()
		call RunAway(0)
		loop
			exitwhen i>11
			if i!=5 and i!=11 then
				if IsPlayerEnemy(GetLocalPlayer(),Player(i)) then
					set r2=r2+I2R(Get(i,"等级"))
				else
					set r1=r1+I2R(Get(i,"等级"))
				endif
			endif
			set i=i+1
		endloop
		set r1=r2/5.-(r1+I2R(5*Get(99,"等级")))/10.
		if r1>0 then
			set WinScore=R2I(100*Sin(RMinBJ(r1,10)*3.1416/20)+50)
			set LoseScore=R2I(100*Sin(RMinBJ(r1,10)*3.1416/20)-50)
		else
			set WinScore=R2I(50*Sin(RMaxBJ(r1,-20)*3.1416/40)+50)
			set LoseScore=R2I(100*Sin(RMaxBJ(r1,-15)*3.1416/30)-50)
		endif
		if WinScore<1 then
			set WinScore=1
		endif
		if LoseScore<-150 then
			set LoseScore=-150
		endif
        set MU_Wins[GetPlayerId(GetLocalPlayer())] = Get(99, "连胜")
		call Set(99,"经验",Get(99,"经验")+LoseScore)
		call SetLevel()
		if not IsPlayerObserver(GetLocalPlayer()) then
			call Set(99,"局数",Get(99,"局数")+1)
			call Set(99,"胜率",100*Get(99,"胜利")/Get(99,"局数"))
            call Set(99,"连胜", 0)
		endif
		call Save()
	endfunction

	function RunB takes nothing returns nothing
		call DestroyTimer(GetExpiredTimer())
		set MaxExp=999999
		call RunAway(1)
	endfunction
	//注册
	function InitRecord takes nothing returns nothing
		local integer i=0
		local trigger trg=CreateTrigger()
		local real r1=0
		local real r2=0
		local integer rs=0
		call DestroyTimer(GetExpiredTimer())
        set IsGameOver = true
		loop
			exitwhen i>15
			if IsPlayerObserver(Player(i)) then
				set GC[i]=InitGameCache("Nothing")
			else
				set GC[i]=InitGameCache("11SAV@"+I2S2(i))
			endif
			call TriggerRegisterPlayerChatEvent(trg,Player(i),"",false)
			set i=i+1
		endloop
		call TriggerAddCondition(trg,Condition(function InitTest))
		set GC[99]=GC[GetPlayerId(GetLocalPlayer())]
		call StoreString(GC[99],"","Title@"+I2S2(0),"局数")
		call StoreString(GC[99],"","Title@"+I2S2(1),"连胜")
		call StoreString(GC[99],"","Title@"+I2S2(2),"助攻王")
		call StoreString(GC[99],"","Title@"+I2S2(3),"节操")
		call StoreString(GC[99],"","Title@"+I2S2(4),"胜率")
		call StoreString(GC[99],"","Title@"+I2S2(5),"战神")
		call StoreString(GC[99],"","Title@"+I2S2(6),"逃跑")
		call StoreString(GC[99],"","Title@"+I2S2(7),"MVP")
        if not sys.JAPI then
            return
        endif
        set IsGameOver = false
		call TimerStart(CreateTimer(),1200,false,function RunB)
		call TimerStart(CreateTimer(),60,true,function MinTimer)
		set trg=CreateTrigger()
		set i=0
		loop
			exitwhen i>11
			call TriggerRegisterPlayerEvent(trg,Player(i),EVENT_PLAYER_LEAVE)
			set i=i+1
		endloop
		call TriggerAddCondition(trg,Condition(function PlayerLeave))
		set BaseUnit[0]=gg_unit_hcas_0015
		set BaseUnit[1]=gg_unit_hcas_0020
		//call BJDebugMsg(GetUnitName(BaseUnit[0]))
		//call BJDebugMsg(GetUnitName(BaseUnit[1]))
		set trg=CreateTrigger()
		call TriggerRegisterUnitEvent(trg,BaseUnit[0],EVENT_UNIT_DEATH)
		call TriggerRegisterUnitEvent(trg,BaseUnit[1],EVENT_UNIT_DEATH)
		call TriggerAddCondition(trg,Condition(function BaseDestroy))
		set trg=CreateTrigger()
		call TriggerRegisterPlayerUnitEvent(trg,GetOwningPlayer(BaseUnit[0]),EVENT_PLAYER_UNIT_DEATH,null)
		call TriggerRegisterPlayerUnitEvent(trg,GetOwningPlayer(BaseUnit[1]),EVENT_PLAYER_UNIT_DEATH,null)
		call TriggerAddCondition(trg,Condition(function BuildingDestroy))
		set trg=null

        //Set(99,"V",4) --被下面的函数取代
        if not baka.newMap() then
            call Save()
            set IsGameOver = true
            return
        endif
		if not CountPlayer() then
			call Save()
			release@ set IsGameOver=true
			release@ return
		endif
        release@ RunA()
        //set MVP = true //test
		call BJDebugMsg("|cffcc00ff积分系统已经开启，游戏结束后请在屏幕上显示“积分已保存”后再离开游戏")
		//call BJDebugMsg("|cffcc00ff该版本为2.5D正式版.游戏结束时,你可以额外获得200(胜)/100(负)的经验")
		call Save()
		//call BJDebugMsg("积分初始化完成")
	endfunction

	private void Init(){
		call TimerStart(CreateTimer(),0,false,function InitRecord)
	}
endlibrary
########
########
//TESH.scrollpos=0
//TESH.alwaysfold=0
<?
import("Moe_Init.lua")[[
    jass_ext.EnableConsole()
]]

import("Moe_RecordFix.lua")[[
    --分割字符串
    string.split = function(str, tos)
        local x = 1
        local strl = string.len(str)
        local tosl = string.len(tos)
        local strs = {}
        for y = 1, strl do
            if string.sub(str, y, y+tosl-1) == tos then
                table.insert(strs, string.sub(str, x, y-1))
                x = y + tosl
            end
        end
        if strl >= x then
            table.insert(strs, string.sub(str, x, strl))
        end
        return strs
    end

    --连接字符串
    string.concat = function(t, cs)
        cs = cs or ""
        rs = ""
        for _,s in ipairs(t) do
            if rs == "" then
                rs = rs .. s
            else
                rs = rs .. cs .. s
            end
        end
        return rs
    end

    setmetatable(_G, { __index = jass })

    print = function(i, s)
        if s then
            DisplayTimedTextToPlayer(Player(i), 0, 0, 60, s)
        else
            DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, 60, i)
        end
    end

    local hash = function(t)
        local r = 1
        for i, v in ipairs(t) do
            r = (v*r+r*i)%7619149571
        end
        return r
    end

    local nameHash = function(v)
        local r = {}
        local l = string.len(v)
        for i = 1, l do
            local c = string.sub(v, i, i)
            table.insert(r, string.byte(c))
        end
        return hash(r)
    end

    local ks = "校验,杀敌,助攻,经验,荣誉,MVP,局数,助攻王,战神,胜率"
    local name = {}
    local trg = CreateTrigger()
    for i = 0, 11 do
        name[i] = GetPlayerName(Player(i))
        TriggerRegisterPlayerChatEvent(trg, Player(i), "run ", false)
    end
    TriggerAddCondition(trg, Condition(
        function()
            if LoadBoolean(Lua_HT, 0, 0) then return end
            local s = string.sub(GetEventPlayerChatString(), 5)
            local i = GetPlayerId(GetTriggerPlayer())
            if LoadInteger(Lua_HT, i, Lua_rf) >= 1 then
                print(i, "你已经恢复过积分了")
                return
            end
            local k = string.split(ks, ",")
            local v = string.split(s, ",")
            for j, key in ipairs(k) do
                if key == "校验" then
                    local h = v[1]
                    v[1] = nameHash(name[i])
                    local hash = hash(v)
                    if math.floor(hash) ~= math.floor(h) then
                        print(i, "积分校验失败,请确认输入")
                        return
                    end
                else
                    print(i, string.format("(%s, %s, %s)", i, key, v[j]))
                    SaveStr(Lua_HT, Lua_key, j, key)
                    SaveInteger(Lua_HT, Lua_value, j, v[j])
                end
            end
            SaveBoolean(Lua_HT, 0, 0, true)
            print(i, "积分恢复成功")
            SaveInteger(Lua_HT, i, Lua_rf, 1 + LoadInteger(Lua_HT, i, Lua_rf))
            SaveInteger(Lua_HT, 0, 0, i)
            TimerStart(Lua_timer, 0, false, nil)
        end
    ))
]]?>

library RecordFix initializer Init needs Record
    hashtable Lua_HT = InitHashtable()
    int Lua_rf = 1
    int Lua_key = 2
    int Lua_value = 3
    timer Lua_timer = CreateTimer()

    bool Lua_RecodFix(){
        int i = LoadInteger(Lua_HT, 0, 0)
        int x = 2
        loop
            exitwhen LoadStr(Lua_HT, Lua_key, x) == null
            Set(i, LoadStr(Lua_HT, Lua_key, x), LoadInteger(Lua_HT, Lua_value, x))
            x++
        endloop
        Set(i, "胜利", Get(i, "局数") * Get(i, "胜率") / 100)
        Set(i, "rf", 1+Get(i, "rf"))
        SaveInteger(Lua_HT, i, Lua_rf, Get(i, "rf"))
        SetLevel()
        Save()
        SaveBoolean(Lua_HT, 0, 0, false)
        return false
    }

    private void StartLua(){
        DestroyTimer(GetExpiredTimer())
        int i = 0
        loop
            exitwhen i > 11
            SaveInteger(Lua_HT, i, Lua_rf, Get(i, "rf"))
            i++
        endloop
        trigger trg = CreateTrigger()
        TriggerRegisterTimerExpireEvent(trg, Lua_timer)
        TriggerAddCondition(trg, Condition(function Lua_RecodFix))
        trg = null
    }

    private void Init(){
        return //不再使用
        //Cheat("run Moe_Init.lua")
        Cheat("run Moe_RecordFix.lua")
        TimerStart(CreateTimer(), 0.1, false, function StartLua)
    }

endlibrary
########
########
//TESH.scrollpos=310
//TESH.alwaysfold=0
//直接挂载YDWE的伤害事件
#include "YDWETriggerEvent.j"

library eventLibrary initializer Init needs baseLibrary

    struct Event
        static hashtable HT = InitHashtable()

        static int index = -1
        static unit u_from[]
        static unit u_to[]
        static bool event_skip[]

        /*
        跳过自定义事件的剩余触发
        */
        static void SkipTriggers(){
            event_skip[index] = true
        }

        /*
        任意单位发动指定技能事件
        同一个组合内只能保存一个触发器
        */

        static void AnyUnitSkill(trigger trg, int i, int id){
            SaveTriggerHandle(HT, i, id, trg)
        }

        static void skillEventAction(){
            eventid id = GetTriggerEventId()
            trigger trg
            if id == EVENT_PLAYER_UNIT_SPELL_CHANNEL
                trg = LoadTriggerHandle(HT, 1, GetSpellAbilityId())
            elseif id == EVENT_PLAYER_UNIT_SPELL_CAST
                trg = LoadTriggerHandle(HT, 2, GetSpellAbilityId())
            elseif id == EVENT_PLAYER_UNIT_SPELL_EFFECT
                trg = LoadTriggerHandle(HT, 3, GetSpellAbilityId())
            elseif id == EVENT_PLAYER_UNIT_SPELL_ENDCAST
                trg = LoadTriggerHandle(HT, 4, GetSpellAbilityId())
            elseif id == EVENT_PLAYER_UNIT_SPELL_FINISH
                trg = LoadTriggerHandle(HT, 5, GetSpellAbilityId())
            endif
            if trg != null and TriggerEvaluate(trg)
                TriggerExecute(trg)
            endif
            id = null
            trg = null
        }

        static void initSkillEvent(){
            trigger trg = CreateTrigger()
            TriggerRegisterAnyUnitEventBJ(trg, EVENT_PLAYER_UNIT_SPELL_CAST)
            TriggerRegisterAnyUnitEventBJ(trg, EVENT_PLAYER_UNIT_SPELL_CHANNEL)
            TriggerRegisterAnyUnitEventBJ(trg, EVENT_PLAYER_UNIT_SPELL_EFFECT)
            TriggerRegisterAnyUnitEventBJ(trg, EVENT_PLAYER_UNIT_SPELL_ENDCAST)
            TriggerRegisterAnyUnitEventBJ(trg, EVENT_PLAYER_UNIT_SPELL_FINISH)
            TriggerAddCondition(trg, Condition(function Event.skillEventAction))
            trg = null
        }

        /*
        任意单位获得指定技能事件
        一个技能下只能保存一个触发器
        */

        static void GetSkill(trigger trg, int id){
            SaveTriggerHandle(HT, StringHash("获得技能事件"), id, trg)
        }

        static void GetSkill_Action(){
            trigger trg = LoadTriggerHandle(HT, StringHash("获得技能事件"), GetSpellAbilityId())
            if trg != null and TriggerEvaluate(trg) then
                TriggerExecute(trg)
            endif
            trg = null
        }

        static void initGetSkill(){
            return //暂不使用
            trigger trg = CreateTrigger()
            TriggerRegisterAnyUnitEventBJ(trg, EVENT_PLAYER_HERO_SKILL)
            TriggerAddCondition(trg, Condition(function Event.GetSkill_Action))
            trg = null
        }

        /*
        任意伤害事件
        */

        static trigger damageEventTrigger1[]
        static trigger damageEventTrigger2[]
        static trigger damageEventTrigger3[]
        static trigger damageEventTrigger4[]
        static trigger damageEventTrigger5[]
        static trigger damageEventTrigger6[]
        static int damageCount1 = 0
        static int damageCount2 = 0
        static int damageCount3 = 0
        static int damageCount4 = 0
        static int damageCount5 = 0
        static int damageCount6 = 0

        //任意单位/英雄/非英雄 受到 任意伤害/攻击伤害/非攻击伤害/致命伤害
        static void AnyUnitDamage(trigger trg, int i1, int i2){
            bool hero, nothero, attack, notattack, dying
            if i1 == 0 then
                hero = true
                nothero = true
            elseif i1 == 1 then
                hero = true
                nothero = false
            elseif i1 == 2 then
                hero = false
                nothero = true
            endif
            if i2 == 0 then
                attack = true
                notattack = true
                dying = false
            elseif i2 == 1 then
                attack = true
                notattack = false
                dying = false
            elseif i2 == 2 then
                attack = false
                notattack = true
                dying = false
            elseif i2 == 3 then
                attack = false
                notattack = false
                dying = true
            endif
            int h = GetHandleId(trg)
            SaveInteger(HT, h, 0, 1)
            define define_InitTrigger(n) = {
                damageEventTrigger##n[++ damageCount##n] = trg
                SaveInteger(HT, h, n, 1)
            }
            if hero then
                if attack then
                    define_InitTrigger(1)

                endif
                if notattack then
                    define_InitTrigger(2)

                endif
                if dying then
                    define_InitTrigger(5)

                endif
            endif
            if nothero then
                if attack then
                    define_InitTrigger(3)

                endif
                if notattack then
                    define_InitTrigger(4)

                endif
                if dying then
                    define_InitTrigger(6)

                endif
            endif

            undef define_InitTrigger
        }

        static unit damage_to[]
        static real damage_reduce[]

        static void damageReduce2(){
            timer t = CreateTimer()
            int h = GetHandleId(t)
            UnitAddAbility(damage_to[index], 'A0RJ')
            SaveUnitHandle(YDHT, h, 0, damage_to[index])
            TimerStart(t, 0, false, \
                lambda void(){
                    timer t = GetExpiredTimer()
                    int h = GetHandleId(t)
                    unit u = LoadUnitHandle(YDHT, h, 0)
                    real hp = GetUnitState(u, UNIT_STATE_LIFE)
                    DestroyTimer(t)
                    FlushChildHashtable(YDHT, h)
                    UnitRemoveAbility(u, 'A0RJ')
                    SetUnitState(u, UNIT_STATE_LIFE, hp)
                    u = null
                    t = null
                }\
            )
            t = null
        }

        static void damageReduce(){
            real reduce = damage_reduce[index]
            real damage = GetEventDamage()
            if reduce > damage then
                reduce = damage
            endif
            real life = GetUnitState(damage_to[index], UNIT_STATE_LIFE) + reduce
            if life > GetUnitState(damage_to[index], UNIT_STATE_MAX_LIFE) then
                //血牌法抵挡伤害
                damageReduce2()
            endif
            SetUnitState(damage_to[index], UNIT_STATE_LIFE, life)
            damage_reduce[index] = 0
        }

        static bool damageEvent_need_clear1 = false
        static bool damageEvent_need_clear2 = false
        static bool damageEvent_need_clear3 = false
        static bool damageEvent_need_clear4 = false
        static bool damageEvent_need_clear5 = false
        static bool damageEvent_need_clear6 = false

        static bool damageEvent_Enable = true

        static void damageEventAction(){
            if GetEventDamage() == 0 or not damageEvent_Enable then
                return
            endif

            int i
            index ++
            damage_to[index] = GetTriggerUnit()
            bool attack = UnitRemoveAbility(damage_to[index], 'B039') or UnitRemoveAbility(damage_to[index], 'A0OB')

            define define_TriggerExecute(n) = {
                i = 1

                //检查是否要清理触发器
    release@    if damageEvent_need_clear##n and index == 0 then
    debug@      if damageEvent_need_clear##n then
    debug@          if index != 0 then
    debug@              BJDebugMsg("<清理伤害事件>被跳过")
    debug@          else
                    damageEvent_need_clear##n = false
                    int x = 0
                    loop
                        exitwhen i > damageCount##n
                        if damageEventTrigger##n[i] == null then
                            x ++
                        elseif x != 0 then
                            damageEventTrigger##n[i - x] = damageEventTrigger##n[i]
                        endif
                        i ++
                    endloop
                    damageCount##n -= x
                    i = 1
    debug@          endif
                endif

                //循环运行触发器
                event_skip[index] = false
                loop
                    exitwhen i > damageCount##n or event_skip[index]
                    if IsTriggerEnabled(damageEventTrigger##n[i]) and TriggerEvaluate(damageEventTrigger##n[i]) then
                        TriggerExecute(damageEventTrigger##n[i])
                    endif
                    i ++
                endloop
            }

            real life

            if IsUnitType(damage_to[index], UNIT_TYPE_HERO) and not IsUnitType(damage_to[index], UNIT_TYPE_SUMMONED) then
                if attack then
                    define_TriggerExecute(1)
                else
                    define_TriggerExecute(2)
                endif
                //检查是否致命
                life    = GetWidgetLife(damage_to[index])
                if life + damage_reduce[index] - GetEventDamage() < 0.5 then
                    define_TriggerExecute(5)
                    if event_skip[index] then
                        damage_reduce[index] = GetEventDamage() - life + 0.5
                    endif
                endif
            else
                if attack then
                    define_TriggerExecute(3)
                else
                    define_TriggerExecute(4)
                endif
                //检查是否致命
                life    = GetWidgetLife(damage_to[index])
                if life + damage_reduce[index] - GetEventDamage() < 0.5 then
                    define_TriggerExecute(6)
                    if event_skip[index] then
                        damage_reduce[index] = GetEventDamage() - life + 0.5
                    endif
                endif
            endif

            undef define_TriggerExecute

            if damage_reduce[index] != 0 then
                damageReduce()
            endif

            index --
        }

        static void ReduceDamage(real r){
            damage_reduce[index] += r
        }

        //重置伤害来源
        static unit Damage_from = null
        static unit Real_damage_from = null

        static unit GetDamageFrom(){
            Damage_from = GetEventDamageSource()

            if Damage_from == null then
                return null
            endif

            Real_damage_from = LoadUnitHandle(YDHT, GetHandleId(Damage_from), StringHash("真实伤害来源"))
            if Real_damage_from == null then
                return Damage_from
            endif

            return Real_damage_from
        }
        
        static unit GetOriginDamageFrom(){
            return GetEventDamageSource()
        }
        
        #define GetEventDamageSource() Event.GetDamageFrom()

        static void DamageEventDestroy(trigger trg, int h){
            if LoadInteger(HT, h, 0) == 1 then
                int i1 = LoadInteger(HT, h, 1)
                int i2 = LoadInteger(HT, h, 2)
                int i3 = LoadInteger(HT, h, 3)
                int i4 = LoadInteger(HT, h, 4)
                int i5 = LoadInteger(HT, h, 5)
                int i6 = LoadInteger(HT, h, 6)

                define define_DestroyTrigger(n) = {
                    if i##n == 1 then
                        loop
                            exitwhen i##n > damageCount##n
                            if trg == damageEventTrigger##n[i##n] then
                                damageEventTrigger##n[i##n] = null
                                i##n = damageCount##n
                                damageEvent_need_clear##n = true
                            endif
                            i##n ++
                        endloop
                    endif
                }

                define_DestroyTrigger(1)

                define_DestroyTrigger(2)

                define_DestroyTrigger(3)

                define_DestroyTrigger(4)

                define_DestroyTrigger(5)

                define_DestroyTrigger(6)

                undef define_DestroyTrigger
            endif
        }

        static void initDamageEvent(){
            //直接挂载YD的伤害事件
            set yd_DamageEventTrigger = CreateTrigger()
            call TriggerAddAction(yd_DamageEventTrigger, function Event.damageEventAction)
            call YDWEAnyUnitDamagedEnumUnit()
        }

        /*
        技能重置事件
        */
        static int SkillCoolReset_skills[]
        static trigger SkillCoolReset_trgs[]
        static int SkillCoolReset_skills_top = 0
        static bool SkillCoolReset_need_clear = false
        static int SkillCoolReset_index = -1

        static void SkillCoolReset(trigger trg, int sid){
            SkillCoolReset_skills_top ++
            SkillCoolReset_skills[SkillCoolReset_skills_top] = sid
            SkillCoolReset_trgs[SkillCoolReset_skills_top] = trg

            //记录
            SaveBoolean(HT, GetHandleId(trg), StringHash("技能重置事件"), true)
        }

        static void UnitResetCooldown_Hook(unit u, int sid){
            if sid == 0 then
                UnitResetCooldown(u)
            endif
            int i = 1
            index ++
            SkillCoolReset_index ++
release@    if SkillCoolReset_need_clear and index == 0 then
debug@      if SkillCoolReset_need_clear then
debug@          if SkillCoolReset_index != 0 then
debug@              BJDebugMsg("<清理冷却事件>被跳过")
debug@          else
                SkillCoolReset_need_clear = false
                int x = 0
                loop
                    exitwhen i > SkillCoolReset_skills_top
                    if SkillCoolReset_trgs[i] == null then
                        x ++
                    elseif x != 0 then
                        SkillCoolReset_trgs[i - x] = SkillCoolReset_trgs[i]
                        SkillCoolReset_skills[i - x] = SkillCoolReset_skills[i]
                    endif
                    i ++
                endloop
                SkillCoolReset_skills_top -= x
                i = 1
debug@          endif
            endif

            event_skip[index] = false
            loop
                exitwhen i > SkillCoolReset_skills_top or event_skip[index]
                if (sid == 0 or sid == SkillCoolReset_skills[i]) and GetUnitAbilityLevel(u, SkillCoolReset_skills[i]) != 0 and IsTriggerEnabled(SkillCoolReset_trgs[i]) then
                    u_from[index] = u
                    u_to[index] = u
                    if TriggerEvaluate(SkillCoolReset_trgs[i]) then
                        TriggerExecute(SkillCoolReset_trgs[i])
                    endif
                endif
                u_from[index] = null
                u_to[index] = null
                i ++
            endloop
            index --
            SkillCoolReset_index --
        }

        #define UnitResetCooldown(u) Event.UnitResetCooldown_Hook(u, 0)

        static void SkillCoolEventDestroy(trigger trg, int h){
            if LoadBoolean(HT, h, StringHash("技能重置事件")) then
                int i = 1
                loop
                    exitwhen i > SkillCoolReset_skills_top
                    if SkillCoolReset_trgs[i] == trg then
                        SkillCoolReset_trgs[i] = SkillCoolReset_trgs[SkillCoolReset_skills_top]
                        i = SkillCoolReset_skills_top
                        SkillCoolReset_need_clear = true
                    endif
                    i ++
                endloop
            endif
        }

        /*
        物品获得
        */

        static void ItemPick(trigger trg, int iid){
            SaveTriggerHandle(HT, StringHash("英雄获得物品"), iid, trg)
        }

        static void initItemPick(){
            trigger trg = CreateTrigger()
            TriggerRegisterAnyUnitEventBJ(trg, EVENT_PLAYER_UNIT_PICKUP_ITEM)
            TriggerAddCondition(trg, Condition( \
                lambda void(){
                    if not IsUnitType(GetTriggerUnit(), UNIT_TYPE_HERO) then
                        return
                    endif
                    trigger trg = LoadTriggerHandle(HT, StringHash("英雄获得物品"), GetItemTypeId(GetManipulatedItem()))
                    if trg != null and IsTriggerEnabled(trg) then
                        index ++
                        u_from[index] = GetTriggerUnit()
                        u_to[index] = u_from[index]
                        if TriggerEvaluate(trg) then
                            TriggerExecute(trg)
                        endif
                        u_from[index] = null
                        u_to[index] = null
                        index --
                    endif
                    trg = null
                } \
            ))
            trg = null
        }

        /*
        物品丢弃
        */

        static void ItemDrop(trigger trg, int iid){
            SaveTriggerHandle(HT, StringHash("英雄丢弃物品"), iid, trg)
        }

        static void initItemDrop(){
            trigger trg = CreateTrigger()
            TriggerRegisterAnyUnitEventBJ(trg, EVENT_PLAYER_UNIT_DROP_ITEM)
            TriggerAddCondition(trg, Condition( \
                lambda void(){
                    if not IsUnitType(GetTriggerUnit(), UNIT_TYPE_HERO) then
                        return
                    endif
                    trigger trg = LoadTriggerHandle(HT, StringHash("英雄丢弃物品"), GetItemTypeId(GetManipulatedItem()))
                    if trg != null and IsTriggerEnabled(trg) then
                        index ++
                        u_from[index] = GetTriggerUnit()
                        u_to[index] = u_from[index]
                        if TriggerEvaluate(trg) then
                            TriggerExecute(trg)
                        endif
                        u_from[index] = null
                        u_to[index] = null
                        index --
                    endif
                    trg = null
                } \
            ))
            trg = null
        }

        static void ItemPickDrop(trigger trg, int flag, int iid){
            if flag == 0 then
                ItemPick(trg, iid)
            else
                ItemDrop(trg, iid)
            endif
        }

        /*
        英雄复活
        */
        static int HeroRevive_skills[]
        static trigger HeroRevive_trgs[]
        static int HeroRevive_skills_top = 0
        static bool HeroRevive_need_clear = false

        static void HeroRevive(trigger trg, int sid){
            HeroRevive_skills_top ++
            HeroRevive_skills[HeroRevive_skills_top] = sid
            HeroRevive_trgs[HeroRevive_skills_top] = trg

            //记录
            SaveBoolean(HT, GetHandleId(trg), StringHash("英雄复活事件"), true)
        }

        static bool ReviveHero_Hook(unit u, real x, real y, bool b){
            if ReviveHero(u, x, y, b) then
                int i = 1
                index ++
    release@    if HeroRevive_need_clear and index == 0 then
    debug@      if HeroRevive_need_clear then
    debug@          if index != 0 then
    debug@              BJDebugMsg("<清理复活事件>被跳过")
    debug@          else
                    HeroRevive_need_clear = false
                    int x = 0
                    loop
                        exitwhen i > HeroRevive_skills_top
                        if HeroRevive_trgs[i] == null then
                            x ++
                        elseif x != 0 then
                            HeroRevive_trgs[i - x] = HeroRevive_trgs[i]
                            HeroRevive_skills[i - x] = HeroRevive_skills[i]
                        endif
                        i ++
                    endloop
                    HeroRevive_skills_top -= x
                    i = 1
    debug@          endif
                endif

                event_skip[index] = false
                loop
                    exitwhen i > HeroRevive_skills_top or event_skip[index]
                    if (HeroRevive_skills[i] == 0 or GetUnitAbilityLevel(u, HeroRevive_skills[i]) != 0) and IsTriggerEnabled(HeroRevive_trgs[i]) then
                        u_from[index] = u
                        u_to[index] = u
                        if TriggerEvaluate(HeroRevive_trgs[i]) then
                            TriggerExecute(HeroRevive_trgs[i])
                        endif
                    endif
                    i ++
                endloop
                u_from[index] = null
                u_to[index] = null
                index --
                return true
            endif
            return false
        }

        static bool ReviveHeroLoc_Hook(unit u, location loc, bool b){
            return ReviveHero_Hook(u, GetLocationX(loc), GetLocationY(loc), b)
        }

        #define ReviveHero(u, x, y, b) Event.ReviveHero_Hook(u, x, y, b)
        #define ReviveHeroLoc(u, loc, b) Event.ReviveHeroLoc_Hook(u, loc, b)

        static void HeroReviveEventDestroy(trigger trg, int h){
            if LoadBoolean(HT, h, StringHash("英雄复活事件")) then
                int i = 1
                loop
                    exitwhen i > HeroRevive_skills_top
                    if HeroRevive_trgs[i] == trg then
                        HeroRevive_trgs[i] = null
                        i = HeroRevive_skills_top
                        HeroRevive_need_clear = true
                    endif
                    i ++
                endloop
            endif
        }

        /*
        过程剔除事件
        */
        static void ProcessCovered(trigger trg, int key){
            if process.hashindex[key] == 0 then
                return
            endif
            process.trg[key] = trg
        }

        /*
        技能进度条结束事件
        */
        static void SkillBarEnd(trigger trg, unit bar, int flag){
            if flag == 0 then
                SaveTriggerHandle(YDHT, GetHandleId(bar), StringHash("技能成功"), trg)
            elseif flag == 1 then
                SaveTriggerHandle(YDHT, GetHandleId(bar), StringHash("技能失败"), trg)
            endif
        }

        /*
        英雄注册事件
        */
        static int hero_ids[]
        static trigger hero_trgs[]
        static int hero_ids_top = 0
        static trigger Trg = null

        static void HeroInit(trigger trg, int hid){
            hero_ids_top ++
            hero_ids[hero_ids_top] = hid
            hero_trgs[hero_ids_top] = trg
        }

        static void HeroInit_Start(unit hero){
            int hid = GetUnitTypeId(hero)
            int i = 1
            index ++
            u_from[index] = hero
            u_to[index] = hero
            event_skip[index] = false
            loop
                exitwhen i > hero_ids_top or event_skip[index]
                if (hid == hero_ids[i] or hero_ids[i] == 0) and hero_trgs[i] != null and IsTriggerEnabled(hero_trgs[i]) and TriggerEvaluate(hero_trgs[i]) then
                    TriggerExecute(hero_trgs[i])
                endif
                i ++
            endloop
            u_from[index] = null
            u_to[index] = null
            index --
        }

        //自定义事件

        __USER_EVENT__

        <?
            update('war3map.j',
                function(content)
                    local event_names   = {}
                    local code  = [[
                        static trigger user_%hash%_trgs[]
                        static int user_%hash%_top = 0
                        static int user_%hash%_lock = -1
                        static bool user_%hash%_need_clear = false
                        static string user_%hash%_name = "%name%"

                        static void user_%hash%_Init(trigger trg){
                            user_%hash%_top ++
                            user_%hash%_trgs[user_%hash%_top] = trg

                            int h       = GetHandleId(trg)
                            int count   = LoadInteger(HT, h, StringHash("自定义事件数量")) + 1
                            SaveInteger(HT, h, StringHash("自定义事件数量"), count)
                            SaveStr(HT, h, StringHash("自定义事件名") + count, "s__Event_user_%hash%_Destroy")
                        }

                        static void user_%hash%_Start(){
                            int i = 1
                            call SaveStr(YDHT, StringHash("事件"), StringHash("名称"), "%name%")
                            index ++
                            user_%hash%_lock ++
                release@    if user_%hash%_need_clear and user_%hash%_lock == 0 then
                debug@      if user_%hash%_need_clear then
                debug@          if user_%hash%_lock != 0 then
                debug@              BJDebugMsg("<%name%事件>跳过")
                debug@          else
                debug@          BJDebugMsg("<%name%事件>清理")
                                user_%hash%_need_clear = false
                                int x = 0
                                loop
                                    exitwhen i > user_%hash%_top
                                    if user_%hash%_trgs[i] == null then
                                        x ++
                                    elseif x != 0 then
                                        user_%hash%_trgs[i - x] = user_%hash%_trgs[i]
                                    endif
                                    i ++
                                endloop
                                user_%hash%_top -= x
                                i = 1
                debug@          endif
                            endif

                            event_skip[index] = false
                            loop
                                exitwhen i > user_%hash%_top or event_skip[index]
                                if IsTriggerEnabled(user_%hash%_trgs[i]) and TriggerEvaluate(user_%hash%_trgs[i]) then
                                    TriggerExecute(user_%hash%_trgs[i])
                                endif
                                i ++
                            endloop
                            user_%hash%_lock --
                            index --
                        }

                        static void user_%hash%_Destroy(){
                            int i = 1
                            loop
                                exitwhen i > user_%hash%_top
                                if user_%hash%_trgs[i] == Trg then
                debug@              BJDebugMsg("<%name%事件>移除")
                                    user_%hash%_trgs[i] = null
                                    i = user_%hash%_top
                                    user_%hash%_need_clear = true
                                endif
                                i ++
                            endloop
                        }
                    ]]

                    content = content:gsub('Event%.UserEventStart%(%s-(%S-)%s-%)',
                        function(name)
                            if not event_names[name] then
                                table.insert(event_names, name)
                                event_names[name]   = {
                                    hash    = string_hash(name),
                                    name    = name,
                                }
                            end

                            return ('Event.user_%s_Start()'):format(string_hash(name))
                        end
                    )

                    content = content:gsub('Event%.UserEventInit%(%s-(%S-)%s-,%s-(%S-)%s-%)',
                        function(trg, name)
                            if not event_names[name] then
                                table.insert(event_names, name)
                                event_names[name]   = {
                                    hash    = string_hash(name),
                                    name    = name,
                                }
                            end

                            return ('Event.user_%s_Init(%s)'):format(string_hash(name), trg)
                        end
                    )

                    content = content:gsub('__USER_EVENT__',
                        function()
                            local texts = {}
                            for _, t in ipairs(event_names) do
                                local text = code:gsub('%%(.-)%%',
                                    function(k)
                                        return event_names[t][k]
                                    end
                                )
                                table.insert(texts, text)
                            end
                            return table.concat(texts, '\n\n')
                        end
                    )

                    return content
                end
            )
        ?>

        //删除触发器的hook
        static void DestroyTrigger_Hook(trigger trg){
            int h = GetHandleId(trg)

            DamageEventDestroy(trg, h)

            SkillCoolEventDestroy(trg, h)

            HeroReviveEventDestroy(trg, h)

            int i       = 1
            int count   = LoadInteger(HT, h, StringHash("自定义事件数量"))
            Trg = trg
            loop
                exitwhen i > count
                    ExecuteFunc(LoadStr(HT, h, StringHash("自定义事件名") + count))
                i ++
            endloop

            FlushChildHashtable(HT, h)
            DestroyTrigger(trg)
        }
        #define DestroyTrigger(trg) Event.DestroyTrigger_Hook(trg)


    endstruct

    private void Init(){
        Event.initSkillEvent()
        Event.initDamageEvent()
        Event.initItemPick()
        Event.initItemDrop()
        Event.initGetSkill()
    }
endlibrary
########
########
//TESH.scrollpos=-1
//TESH.alwaysfold=0
library mathLibrary initializer Init needs baseLibrary

    struct math
        /*
        点是否在矩形区域内(起点,角度,长度,宽度,判定点)
        自动清除2个点
        */
        static bool isPointInRect(location A, real a, real l, real w, location B, integer i){
            real Ax=GetLocationX(A)
            real Ay=GetLocationY(A)
            real Bx=GetLocationX(B)
            real By=GetLocationY(B)
            real dx=Bx-Ax
            real dy=By-Ay
            real d=SquareRoot(dx*dx+dy*dy)
            real a2=bj_RADTODEG*Atan2(dy,dx)
            real x=GetLocationX(A)+d*Cos((a2-a)*bj_DEGTORAD)
            real y=GetLocationY(A)+d*Sin((a2-a)*bj_DEGTORAD)
            if i == 1
                RemoveLocation(A)
                RemoveLocation(B)
            elseif i == 2
                RemoveLocation(A)
            elseif i == 3
                RemoveLocation(B)
            endif
            return x>Ax and x<Ax+l and y>Ay-0.5*w and y<Ay+0.5*w
        }


        /*
        令(点)向(方向)移动(距离),(检查地图边界)
        */
        static void MoveLocationAngle(location loc,real a,real r ,bool b){
            if b
                MoveLocation(loc,YDWECoordinateX((GetLocationX(loc)+(r*Cos(bj_DEGTORAD*a)))),YDWECoordinateY((GetLocationY(loc)+(r*Sin(bj_DEGTORAD*a)))))
            else
                MoveLocation(loc,GetLocationX(loc)+(r*Cos(bj_DEGTORAD*a)),GetLocationY(loc)+(r*Sin(bj_DEGTORAD*a)))
            endif
        }

        /*
        极坐标
        自动清除引用点
        */
        static location PolarProjectionMU(location source, real dist, real angle){
            local real x = GetLocationX(source) + dist * Cos(angle * bj_DEGTORAD)
            local real y = GetLocationY(source) + dist * Sin(angle * bj_DEGTORAD)
            call RemoveLocation(source)
            return Location(x, y)
        }

        /*
        单位到点的距离/角度
        */
        static real U2L(unit u,location p,int i,bool b){
            real rs
            if i == 0
                real x = GetUnitX(u)-GetLocationX(p)
                real y = GetUnitY(u)-GetLocationY(p)
                rs = SquareRoot(x*x+y*y)
            elseif i == 1
                rs = bj_RADTODEG * Atan2(GetLocationY(p) - GetUnitY(u), GetLocationX(p) - GetUnitX(u))
            endif
            if b
                RemoveLocation(p)
            endif
            return rs
        }

        /*
        2点间距离/角度
        */
        static real L2L(location locA, location locB, int i, int j){
            real rs
            if i == 0
                real x = GetLocationX(locA) - GetLocationX(locB)
                real y = GetLocationY(locA) - GetLocationY(locB)
                rs = SquareRoot(x*x+y*y)
            elseif i == 1
                rs = bj_RADTODEG * Atan2(GetLocationY(locB) - GetLocationY(locA), GetLocationX(locB) - GetLocationX(locA))
            endif
            if j == 1
                RemoveLocation(locA)
                RemoveLocation(locB)
            elseif j == 2
                RemoveLocation(locA)
            elseif j == 3
                RemoveLocation(locB)
            endif
            return rs
        }

        /*
        获取2个角度的夹角
        参数可以是任意范围
        返回值范围是0-180
        */
        static real Angle(real r1,real r2){
            real r = r1 - r2
            r -= R2I(r/360.)*360.
            if r > 180.
                return 360.-r
            elseif r < -180
                return 360.+r
            elseif r < 0
                return - r
            endif
            return r
        }

        /*
        点在多边形内部
        只支持凸多边形
        */
        private static real PolygonX[]
        private static real PolygonY[]

        static void SetPolygonLocation(int i,real x,real y){
            PolygonX[i]=x
            PolygonY[i]=y
        }

        static bool InsidePolygon(location p,int a,int b,bool bb){
            int n=b
            int count1 = 0
            int count2 = 0
            real value = 0
            loop
                exitwhen a>b
                value = (GetLocationX(p) - PolygonX[n]) * (PolygonY[a] - PolygonY[n]) - (GetLocationY(p) - PolygonY[n]) * (PolygonX[a] - PolygonX[n])
                if value > 0
                    count1++
                elseif value < 0
                    count2++
                endif
                n=a
                a++
            endloop
            if bb
                RemoveLocation(p)
            endif
            return (0 == count1 or 0 == count2)
        }

    endstruct

    private void Init(){
    }

endlibrary
########
########
//TESH.scrollpos=-1
//TESH.alwaysfold=0
library stringLibrary initializer Init needs baseLibrary

    struct String
        private static string char2AllString = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"

        static string char2(int n){
            if n > 0 and n < 27
                return SubString(char2AllString, n - 1, n)
            endif
            return ""
        }

        static int byte2(string s){
            int i = 0
            loop
                exitwhen i > 26
                if StringCase(s, true) == SubString(char2AllString, i, i + 1) then
                    return i + 1
                endif
                i ++
            endloop
            if i > 9 then
                i = 9
            endif
            return 0
        }

        static string Str[]
        static int StrCount

        static string GetStr(int i){
            if i > .StrCount then
                return ""
            endif
            return .Str[i]
        }

        static int Split(string sss, string sp){
            integer count = 0
            integer i = 0
            integer j = 0
            string s = ""
            int length = StringLength(sss)
            int lengthp = StringLength(sp)
            .Str[0] = sss
            if sss == "" then
                return 0
            endif
            loop
                s = SubString(sss, i, i + lengthp)
                exitwhen s == "" or s == null or i > length
                if s == sp then
                    count = count + 1
                    .Str[count] = SubString(sss, j, i)
                    j = i + lengthp
                    i = j
                endif
                i = i + 1
            endloop
            count = count + 1
            .Str[count] = SubString(sss, j, i)
            .StrCount=count
            return count
        }
    endstruct

    private void Init(){
    }
endlibrary
########
########
//TESH.scrollpos=-1
//TESH.alwaysfold=0
library playerLibrary initializer Init needs baseLibrary

    struct sPlayer
        static string name[]
        static string base_name[]

        static string GetPlayerName2(player p){
            return name[GetPlayerId(p)]
        }

        static void SetPlayerName2(player p, string n){
            SetPlayerName(p, n)
            name[GetPlayerId(p)] = n
            Lua_hook(p, "fresh_name")
        }

        static string GetPlayerBaseName(player p){
            return base_name[GetPlayerId(p)]
        }

    endstruct

    private void Init(){
        int i = 0
        loop
            exitwhen i > 11
            sPlayer.name[i] = GetPlayerName(Player(i))
            sPlayer.base_name[i] = sPlayer.name[i]
            Lua_hook(Player(i), "fresh_name")
            i ++
        endloop
    }

    #define GetPlayerName(p) sPlayer.GetPlayerName2(p)
    #define SetPlayerName(p, s) sPlayer.SetPlayerName2(p, s)

endlibrary
########
########
//TESH.scrollpos=747
//TESH.alwaysfold=0
library bakaLibrary initializer Init needs baseLibrary

    //反全图
    struct maphack
        static bool safe_mode = false //安全模式

        static unit heroes[] //英雄
        static int heroCount = 0 //英雄计数
        static int heroState[] //英雄可见度状态 0=未知 1=可见 2=不可见
        static real heroHeight[] //英雄高度
        static image heroShadow[] //英雄阴影

        //注册英雄
        static void InitHero(unit hero){
            int i = 1
            loop
                exitwhen GetUnitTypeId(heroes[i]) == 0
                if heroes[i] == hero
                    return
                endif
                i ++
            endloop

            heroes[i] = hero
            heroState[i] = 0
            heroHeight[i] = 0
            heroShadow[i] = baka.Image

            if i > heroCount then
                heroCount = i
            elseif GetUnitTypeId(heroes[heroCount]) == 0 then
                heroCount --
            endif

            UnitAddAbility(hero, 'Arav')
            UnitRemoveAbility(hero, 'Arav')
            debug@ BJDebugMsg("<FMH>添加[" + GetUnitName(hero) + "] 位置[" + I2S(i) + "] 计数:" + I2S(heroCount))

            //添加BUG图标,看到就会崩,防看技能
            if safe_mode or (not IsUnitEnemy(hero, sys.selfp)) or IsPlayerObserver(sys.selfp) then
                UnitAddAbility(hero, 'A0QU')
            else
                UnitAddAbility(hero, 'A0QV')
            endif
            UnitMakeAbilityPermanent(hero, true, 'A0QU')
            UnitMakeAbilityPermanent(hero, true, 'A0QV')
        }

        //偶尔迁移压缩一下数组
        static void zip(){
            int i = 1
            loop
                exitwhen i > heroCount
                if GetUnitTypeId(heroes[i]) == 0 then
                    int j = heroCount
                    loop
                        exitwhen j <= i
                        if GetUnitTypeId(heroes[j]) != 0 then
                            heroes[i] = heroes[j]
                            heroState[i] = heroState[j]
                            heroHeight[i] = heroHeight[j]
                            heroShadow[i] = heroShadow[j]
                            heroes[j] = null
                            debug@ BJDebugMsg("<FMH>移动[" + GetUnitName(heroes[i]) + "] 新的位置[" + I2S(i) + "] 之前的位置[" + I2S(j) + "]")
                            j = 0
                        endif
                        j --
                    endloop
                    heroCount --
                endif
                i ++
            endloop
        }

        //周期检测
        static int check_start_index = 1

        static void TimerFunc(){
            int i = check_start_index
            loop
                exitwhen i > heroCount
                    if IsUnitVisible(heroes[i], sys.selfp) then //单位是否对本地可见
                        //如果可见
                        if heroState[i] != 1 then
                            heroState[i] = 1
                            UnitSetUsesAltIcon(heroes[i], false) //关闭标志,显示英雄图标
                            SetUnitFlyHeight(heroes[i], heroHeight[i], 0) //设置高度为实际高度
                            SetImageColor(heroShadow[i], 255, 255, 255, 255) //显示阴影图像
                        endif
                    elseif GetUnitTypeId(heroes[i]) != 0 then
                        //如果不可见
                        if heroState[i] != 2 then
                            heroState[i] = 2
                        endif
                        UnitSetUsesAltIcon(heroes[i], true) //打开标志,小地图上不显示英雄图标
                        SetUnitFlyHeight(heroes[i], 10000, 0) //让英雄飞上天
                        SetImageColor(heroShadow[i], 255, 255, 255, 0) //隐藏阴影图像
                    endif
                i ++
            endloop
        }

        //设置高度
        static void SetHeight(unit u, real h, real r){
            if IsUnitType(u, UNIT_TYPE_GIANT) then
                return
            endif

            if IsUnitType(u, UNIT_TYPE_HERO) then
                int i = 1
                loop
                    exitwhen i > heroCount
                    if heroes[i] == u then
                        heroHeight[i] = h
                        if heroState[i] != 2 then
                            SetUnitFlyHeight(u, h, 0)
                        endif
                        return
                    endif
                    i ++
                endloop
            endif

            SetUnitFlyHeight(u, h, r)
        }

        //获取高度
        static real GetHeight(unit u){
            if IsUnitType(u, UNIT_TYPE_HERO) then
                int i = 1
                loop
                    exitwhen i > heroCount
                    if heroes[i] == u then
                        return heroHeight[i]
                    endif
                    i ++
                endloop
            endif

            return GetUnitFlyHeight(u)
        }

        //正义巡视者系统
        static unit visitors[]
        static int visitorsCount = 0

        static timer check_timer = CreateTimer()
        static unit check_unit
        static fogmodifier fog[]

        static int check_id = 0

        //检测是否是因为BUG模型而崩溃
        static void check_MH_crash(){
            return
            local player p = GetTriggerPlayer()
            local integer i = baka.spid[GetPlayerId(p)]
            if GetStoredInteger(sys.GC, "MH1", I2S(i)) > GetStoredInteger(sys.GC, "MH2", I2S(i)) then
                if sys.isIn11() then
                    Lua_hook(sys.selfp, "maid_chat 主人主人,刚刚【" + GetPlayerName(p) + "】开图被我发现了")
                    Lua_hook(sys.selfp, "maid_chat 我果断把他踢掉了,快夸奖我一下吧~")
                else
                    BJDebugMsg(GetPlayerName(p) + "|cffff1111因为使用全图作弊工具被T出游戏啦!|r")
                endif
            endif
            p = null
        }

        static void timerFunc3(){
            SetUnitPosition(check_unit, -4000, 8000)

            ShowUnit(check_unit, false)

            RemoveUnit(check_unit)

            int i = 0
            loop
                exitwhen i > 9
                if fog[i] != null then
                    DestroyFogModifier(fog[i])
                    fog[i] = null
                    //debug@ Lua_hook(sys.selfp, "print p4:i=" + I2S(i))
                endif
                i ++
            endloop

            //发送一个数据
            TimerStart(check_timer, 0.2, false, \
                lambda void (){
                    StoreInteger(sys.GC, "MH2", I2S(sys.self), R2I(sys.getTime()))
                    SyncStoredInteger(sys.GC, "MH2", I2S(sys.self))
                }\
            )
        }

        static void timerFunc2(unit hero){
            real x = GetUnitX(hero)
            real y = GetUnitY(hero)
            bool flag = false

            int i = 0
            loop
                exitwhen i > 9
                player p = Player(i)

                if /*
                    */not IsVisibleToPlayer(x, y, p) and /*
                    */not IsVisibleToPlayer(x + 256, y, p) and /*
                    */not IsVisibleToPlayer(x - 256, y, p) and /*
                    */not IsVisibleToPlayer(x, y + 256, p) and /*
                    */not IsVisibleToPlayer(x, y - 256, p) /*
                */then

                    fog[i] = CreateFogModifierRadius(p, FOG_OF_WAR_FOGGED, x, y, 128, true, true)
                    FogModifierStart(fog[i])
                    if sys.IsReplay != 1 and sys.selfp == p then
                        flag = true
                    endif
                    //debug@ Lua_hook(sys.selfp, "print p3:i=" + I2S(i))
                else
                    //debug@ Lua_hook(sys.selfp, "print p5:i=" + I2S(i))
                endif

                p = null
                i ++
            endloop


            check_unit = CreateUnit(GetOwningPlayer(hero), 'e08U', -4000, 8000, 0)

            //debug@ BJDebugMsg(R2S(GetUnitX(check_unit)))

            if flag then
                SetUnitFlyHeight(check_unit, 0, 0)
            else
                SetUnitFlyHeight(check_unit, 1000000, 0)
            endif

            if (x < -500 or x > 700) and (y < -1000 and y > 100) then
                SetUnitPosition(check_unit, x, y)
            endif

            UnitRemoveAbility(check_unit, 'Amov')

            //准备销毁BUG模型与视野修正
            TimerStart(check_timer, 0.05, false, function maphack.timerFunc3)
        }



        static void timerFunc(){
            //循环检查
            check_id ++
            if check_id > 9 then
                check_id = 0
            endif

            TimerStart(GetExpiredTimer(), GetRandomInt(3, 5) * 0.7, false, function maphack.timerFunc)

            if ModuloInteger(check_id, 3) == 0 then
                int i = 0
                loop
                    exitwhen i > visitorsCount

                    if GetRandomInt(1, 3) == 2 and GetUnitCurrentOrder(visitors[i]) == 0 then
                        player pl = GetOwningPlayer(visitors[i])

                        real x = GetRandomInt(-100, 100) * 70
                        real y = GetRandomInt(-100, 100) * 70

                        SetUnitX(visitors[i], x)
                        SetUnitY(visitors[i], y)

                        UnitSetUsesAltIcon(visitors[i], true) //打开标志,小地图上不显示英雄图标
                        SetUnitFlyHeight(visitors[i], 1000000, 0) //让英雄飞上天

                        x = GetRandomInt(-100, 100) * 70
                        y = GetRandomInt(-100, 100) * 70

                        IssuePointOrder(visitors[i], "move", x, y)
                        UnitSetUsesAltIcon(visitors[i], true)
                    endif
                    //DestroyEffect(AddSpecialEffectTarget("Tsukiko.mdl", visitors[i], "origin"))
                    i ++
                endloop
            endif

            release@ return

            if safe_mode then
                return
            endif

            //在视野外的英雄头上创建BUG模型;对非该玩家进行特例;对录像进行特例
            //debug@ Lua_hook(sys.selfp, "print p1:check_id=" + I2S(check_id))
            unit hero = udg_player[check_id + 1]

            if GetUnitTypeId(hero) != 0 then
                timerFunc2(hero)

                //发送一个数据
                StoreInteger(sys.GC, "MH1", I2S(sys.self), R2I(sys.getTime()))
                SyncStoredInteger(sys.GC, "MH1", I2S(sys.self))
            endif

            hero = null

        }

        //检查录像(录像模式关闭FMH)
        static void WaitToCheckReplay(){
            if sys.IsReplay == -1 and sys.getTime() < 30 then
                return
            endif

            if sys.getTime() > 25 then
                BJDebugMsg("<录像检查>超时!请汇报BUG(请附带当前玩家信息/是否有玩家退出)")
            endif

            if IsPlayerObserver(sys.selfp) or sys.IsReplay == 1 then
                check_start_index = 10000
            endif

            TimerStart(GetExpiredTimer(), 0.05, true, function maphack.TimerFunc) //启动计时器,周期0.05秒检查视野
        }

        static void InitS(){
            TimerStart(CreateTimer(), 0.5, true, function maphack.WaitToCheckReplay)

            SetAltMinimapIcon("null_16_16.blp") //设置小地图中立标志为透明图标
        }

        static void AfterSP(){
            //创建巡视者
            int i = 0
            loop
                exitwhen i > 9
                player p = Player(i)
                int j = 0
                loop
                    exitwhen j > 4
                    real x = GetRandomInt(-100, 100) * 70
                    real y = GetRandomInt(-100, 100) * 70
                    if IsPlayerAlly(p, sys.selfp) or sys.IsReplay == 1 or GetPlayerTeam(p) == -1 then
                        visitors[visitorsCount] = CreateUnit(p, 'H00H', x, y, 0)
                    else
                        visitors[visitorsCount] = CreateUnit(p, 'H00G', x, y, 0)
                    endif
                    UnitSetUsesAltIcon(visitors[visitorsCount], true) //打开标志,小地图上不显示英雄图标
                    SetUnitFlyHeight(visitors[visitorsCount], 10000, 0) //让英雄飞上天
                    SetHeroLevel(visitors[visitorsCount], 30, false) //设置英雄为满级以免分经验
                    visitorsCount ++
                    j ++
                endloop
                i ++
            endloop
            TimerStart(CreateTimer(), 5, false, function maphack.timerFunc)
            TimerStart(CreateTimer(), GetRandomInt(60, 120), true, function maphack.zip)
            /*
            //修正视野外杀野看不到金钱获取的BUG
            trigger trg = CreateTrigger()
            Event.AnyUnitDamage(trg, 2, 0)
            TriggerAddCondition(trg, Condition( \
                lambda void(){
                    if GetOwningPlayer(GetTriggerUnit()) == Player(12) and GetOwningPlayer(GetEventDamageSource()) == sys.selfp and not IsUnitVisible(GetTriggerUnit(), sys.selfp) then
                        SetUnitFlyHeight(GetTriggerUnit(), 0, 0)
                    endif
                } \
            ))
            */
        }

        #define SetUnitFlyHeightBJ maphack.SetHeight
        #define SetUnitFlyHeight maphack.SetHeight
        #define GetUnitFlyHeight maphack.GetHeight

        static group GetUnitsInRangeOfLocAllSub(real r, location l){
            return YDWEGetUnitsInRangeOfLocMatchingNull(r, l, Condition( \
                lambda bool(){
                    return not IsUnitType(GetFilterUnit(), UNIT_TYPE_TAUREN)
                } \
            ))
        }

        //选取单位不选中特殊单位
        #define YDWEGetUnitsInRangeOfLocAllNull(r, l) maphack.GetUnitsInRangeOfLocAllSub(r, l)
    endstruct



    //专用库
    struct baka
        /*
        (单位) 在吃到好符的几率为 (几率) 的情况下吃了个 (好/坏) 符
        */
        static void lucky(unit u, real r, bool b){
            int i = GetPlayerId(GetOwningPlayer(u))
            int x = Get(i, "L0") + 1
            Set(i, "L0", x)
            int y = Get(i, "L1")
            if b
                y += R2I((100-r)*100)
            else
                y -= R2I(r*100)
            endif
            Set(i, "L1", y)
            int z = Get(i, "幸运")
            z = y/x
            Set(i, "幸运", z)
            Save()
        }

        /*
        OB可以共享玩家(可以看到玩家的技能)
        */
        static void OB(){
            int i = 0
            loop
                exitwhen i > 9
                SetPlayerAlliance(Player(i), Player(10), ALLIANCE_SHARED_CONTROL, true)
                SetPlayerAlliance(Player(i), Player(11), ALLIANCE_SHARED_CONTROL, true)
                i++
            endloop
        }

        /*
        洗牌模式用
        */

        static player spplayer[]
        static int spid[]

        static void InitSP(){
            int i = 0
            loop
                exitwhen i > 15
                spplayer[i] = Player(i)
                spid[i] = i
                i++
            endloop
        }

        static player SPlayer(int i){
            return spplayer[i]
        }

        static int SGetPlayerId(player p){
            return spid[GetPlayerId(p)]
        }

        static group g[]

        //重置变量记录
        static void UnitDefine(){
            unit u1[]
            unit u2[]
            int i = 0
            loop
                exitwhen i > 9
                u1[i] = udg_SmD[i + 1] //生命灯
                u2[i] = udg_wupinqiu[i + 1] //物品球
                i ++
            endloop

            i = 0
            loop
                exitwhen i > 9
                udg_SmD[spid[i] + 1] = u1[i]
                udg_wupinqiu[spid[i] + 1] = u2[i]
                i ++
            endloop
        }

        /*洗牌函数说明
        玩家1-10随机重新组队,并重置所有单位颜色与玩家结盟关系,交换生命灯的位置
        */
        static void Sp(){
            int startLocIndex[] //玩家游戏开始位置的索引
            int i = 0
            int oids[]
            loop
                exitwhen i > 9
                oids[i] = i
                startLocIndex[i] = GetPlayerStartLocation(Player(i))
                //将该玩家的所有单位记录下来准备进行交换
                g[i] = CreateGroup()
                GroupEnumUnitsOfPlayer(g[i], Player(i), null)
                i++
            endloop
            int nids[]
            i = 0
            loop
                exitwhen i > 9
                int index = GetRandomInt(0, 9-i) //随机提取出一个玩家
                int id = oids[index] //找到这个玩家的ID
                nids[i] = id //提取出的玩家放到新的玩家序列中
                int j = index
                loop //将后面的玩家序列往前移动一个位置
                    exitwhen j > 9
                    oids[j] = oids[j+1]
                    j++
                endloop
                i++
            endloop
            i = 0
            loop
                exitwhen i > 9
                spplayer[i] = Player(nids[i])
                spid[nids[i]] = i
                debug@ BJDebugMsg("<洗牌>玩家: " + I2S(nids[i]) + " → 玩家: " + I2S(i))
                SetPlayerStartLocation(spplayer[i], startLocIndex[i])
                SetPlayerColor(spplayer[i], ConvertPlayerColor(i))
                //BJDebugMsg(I2S(nids[i]) + " → " + I2S(i))
                forGroup(u, g[i])
                    SetUnitOwner(u, spplayer[i], true)
                endGroup
                i++
            endloop
            int x = 0
            loop
                exitwhen x > 4
                SetPlayerTeam(spplayer[x], 0)
                int y = 0
                loop
                    exitwhen y > 4
                    SetPlayerAllianceStateAllyBJ(spplayer[x], spplayer[y], true)
                    SetPlayerAlliance(spplayer[x], spplayer[y], ALLIANCE_SHARED_VISION, true)
                    SetPlayerAllianceStateAllyBJ(spplayer[x], spplayer[y+5], false)
                    SetPlayerAlliance(spplayer[x], spplayer[y+5], ALLIANCE_SHARED_VISION, false)
                    y++
                endloop
                SetPlayerAllianceStateAllyBJ(spplayer[x], spplayer[10], true)
                SetPlayerAlliance(spplayer[x], spplayer[10], ALLIANCE_SHARED_VISION, true)
                SetPlayerAllianceStateAllyBJ(spplayer[x], spplayer[11], false)
                SetPlayerAlliance(spplayer[x], spplayer[11], ALLIANCE_SHARED_VISION, false)
                SetPlayerAllianceStateAllyBJ(spplayer[10], spplayer[x], true)
                SetPlayerAlliance(spplayer[10], spplayer[x], ALLIANCE_SHARED_VISION, true)
                SetPlayerAlliance(spplayer[10], spplayer[x], ALLIANCE_HELP_REQUEST, false)
                SetPlayerAllianceStateAllyBJ(spplayer[11], spplayer[x], false)
                SetPlayerAlliance(spplayer[11], spplayer[x], ALLIANCE_SHARED_VISION, false)
                SetPlayerAlliance(spplayer[x], spplayer[x], ALLIANCE_HELP_REQUEST, false)
                x++
            endloop
            x = 5
            loop
                exitwhen x > 9
                SetPlayerTeam(spplayer[x], 1)
                int y = 5
                loop
                    exitwhen y > 9
                    SetPlayerAllianceStateAllyBJ(spplayer[x], spplayer[y], true)
                    SetPlayerAlliance(spplayer[x], spplayer[y], ALLIANCE_SHARED_VISION, true)
                    SetPlayerAllianceStateAllyBJ(spplayer[x], spplayer[y-5], false)
                    SetPlayerAlliance(spplayer[x], spplayer[y-5], ALLIANCE_SHARED_VISION, false)
                    y++
                endloop
                SetPlayerAllianceStateAllyBJ(spplayer[x], spplayer[11], true)
                SetPlayerAlliance(spplayer[x], spplayer[11], ALLIANCE_SHARED_VISION, true)
                SetPlayerAllianceStateAllyBJ(spplayer[x], spplayer[10], false)
                SetPlayerAlliance(spplayer[x], spplayer[10], ALLIANCE_SHARED_VISION, false)
                SetPlayerAllianceStateAllyBJ(spplayer[11], spplayer[x], true)
                SetPlayerAlliance(spplayer[11], spplayer[x], ALLIANCE_SHARED_VISION, true)
                SetPlayerAlliance(spplayer[11], spplayer[x], ALLIANCE_HELP_REQUEST, false)
                SetPlayerAllianceStateAllyBJ(spplayer[10], spplayer[x], false)
                SetPlayerAlliance(spplayer[10], spplayer[x], ALLIANCE_SHARED_VISION, false)
                SetPlayerAlliance(spplayer[x], spplayer[x], ALLIANCE_HELP_REQUEST, false)
                x++
            endloop
            OB()
            //sys.self = SGetPlayerId(sys.selfp)
            //UnitDefine()
        }

        <?
            --取消对Player的define,以免影响config函数导致地图无法启动
            update('war3map.j',
                function(content)
                    return content:gsub('(function InitCustomPlayerSlots takes nothing returns nothing.+)',
                        function(s)
                            s = s:gsub('baka.SPlayer', 'Player')
                            s = s:gsub('baka.SGetPlayerId', 'GetPlayerId')
                            return s
                        end
                    )
                end
            )
        ?>

        //对player进行define以支持洗牌模式
        #define Player(i) baka.SPlayer(i)
        #define ConvertedPlayer(i) baka.SPlayer(i-1)
        #define GetPlayerId(p) baka.SGetPlayerId(p)
        #define GetConvertedPlayerId(p) (baka.SGetPlayerId(p)+1)

        static string thisVerName = "__MAP_VER_NAME__"
        static int thisVer = 0
        static string thatVerName = ""

        static void oldMapTimerFunc(){
            BJDebugMsg("|cff00ccff当前地图版本并非最新版本,积分已经关闭.检测到的最新版本为 |cffffcc00" + thatVerName + "|r")
        }

        static void banMapTimerFunc(){
            BJDebugMsg("|cff00ccff当前地图版本已经废弃,请更换新版本地图进行游戏|r")
        }

        static int getMapVerInt(string name){
            int i1 = S2I(SubString(name, 0, 1)) * 100
            int i2 = S2I(SubString(name, 2, 3)) * 10
            int i3 = String.byte2(SubString(name, 3, 4))
            return i1 + i2 + i3
        }

        static string getMapVerName(int ver){
            string s1 = I2S(ver / 100)
            string s2 = I2S(ModuloInteger(ver, 100) / 10)
            string s3 = String.char2(ModuloInteger(ver, 10))
            return s1 + "." + s2 + s3
        }

        static void oldMap(int thatVer, bool flag){
            thatVerName = getMapVerName(thatVer)
            if flag then
                TimerStart(CreateTimer(), 1, false, function baka.oldMapTimerFunc)
                TimerStart(CreateTimer(), 300, true, function baka.oldMapTimerFunc)
            else
                TimerStart(CreateTimer(), 1, false, null)
                TimerStart(CreateTimer(), 300, true, null)
            endif
        }

        static bool newMap(){
            //设置当前版本号
            thisVer = getMapVerInt(thisVerName)
            debug@ return true
            //寻找所有玩家记录的最新版本
            int thatVer = 0
            int banVer = 0
            int x = 0
            loop
                exitwhen x > 11
                int that = Get(x, "V")
                if that > thatVer
                    thatVer = that
                endif
                int ban = Get(x, "B")
                if ban > banVer
                    banVer = ban
                endif
                x ++
            endloop
            if thatVer > thisVer
                oldMap(thatVer, true) //确认当前玩的地图是旧版本
            else
                oldMap(thatVer, false)
                thatVer = thisVer
            endif
            //更新所有玩家记录的最新版本数据
            x = 0
            loop
                exitwhen x > 11
                if Get(x, "V") < thatVer then
                    Lua_hook(Player(x), "new_version")
                    Set(x, "V", thatVer)
                endif
                Set(x, "B", banVer)
                x ++
            endloop
            //根据情况是否废除当前版本地图
            if banVer >= thisVer
                EnableUserUI(false)
                TimerStart(CreateTimer(), 1, false, function baka.banMapTimerFunc)
                TimerStart(CreateTimer(), 60, true, function baka.banMapTimerFunc)
                return false
            endif
            if thatVer > thisVer
                return false
            endif
            return true
        }

        //动态炸弹人类型
        static group CG1 = CreateGroup() //万物可见
        static group CG2 = CreateGroup() //万物不可见
        static group CG3 = CreateGroup() //极寒可见
        static group CG4 = CreateGroup() //极寒不可见

        static unit CU = null

        static void Check1(){
            CU = GetEnumUnit()
            if IsUnitInvisible(CU, Player(11)) then
                GroupRemoveUnit(CG1, CU)
                GroupAddUnit(CG2, CU)
                UnitAddType(CU, UNIT_TYPE_SAPPER)
                // BJDebugMsg("万物离开视野:" + GetUnitName(CU))
            endif
        }

        static void Check2(){
            CU = GetEnumUnit()
            if IsUnitVisible(CU, Player(11)) then
                GroupRemoveUnit(CG2, CU)
                GroupAddUnit(CG1, CU)
                UnitRemoveType(CU, UNIT_TYPE_SAPPER)
                // BJDebugMsg("万物进入视野:" + GetUnitName(CU))
            endif
        }

        static void Check3(){
            CU = GetEnumUnit()
            if IsUnitInvisible(CU, Player(10)) then
                GroupRemoveUnit(CG3, CU)
                GroupAddUnit(CG4, CU)
                UnitAddType(CU, UNIT_TYPE_SAPPER)
                // BJDebugMsg("极寒离开视野:" + GetUnitName(CU))
            endif
        }

        static void Check4(){
            CU = GetEnumUnit()
            if IsUnitVisible(CU, Player(10)) then
                GroupRemoveUnit(CG4, CU)
                GroupAddUnit(CG3, CU)
                UnitRemoveType(CU, UNIT_TYPE_SAPPER)
                // BJDebugMsg("极寒进入视野:" + GetUnitName(CU))
            endif
        }

        static void CheckVisible(){
            ForGroup(CG1, function baka.Check1)
            ForGroup(CG2, function baka.Check2)
            ForGroup(CG3, function baka.Check3)
            ForGroup(CG4, function baka.Check4)
        }

        static trigger CheckDeath = CreateTrigger()

        static int CheckCount = 0

        static bool CheckSummon(){
            CU = GetSummonedUnit()
            if IsUnitAlly(CU, Player(10)) then
                GroupAddUnit(CG1, CU)
            else
                GroupAddUnit(CG3, CU)
            endif
            TriggerRegisterUnitEvent(CheckDeath, CU, EVENT_UNIT_DEATH)
            CheckCount ++
            // BJDebugMsg("<视野检查> 单位名称[" + GetUnitName(CU) + "] 计数[" + I2S(CheckCount) + "]")
            return false
        }

        static bool SummonDeath(){
            CU = GetTriggerUnit()
            GroupRemoveUnit(CG1, CU)
            GroupRemoveUnit(CG2, CU)
            GroupRemoveUnit(CG3, CU)
            GroupRemoveUnit(CG4, CU)
            CheckCount --
            // BJDebugMsg("<视野检查> 单位名称[" + GetUnitName(CU) + "] 计数[" + I2S(CheckCount) + "]")
            return false
        }

        //注册英雄
        static void InitHero(unit hero){
            //令英雄可以改变高度
            UnitAddAbility(hero, 'Arav')
            UnitRemoveAbility(hero, 'Arav')
            //添加英雄光晕
            UnitAddAbility(hero, 'A087')
            SetPlayerAbilityAvailable(GetOwningPlayer(hero), 'A087', false)
            UnitMakeAbilityPermanent(hero, true, 'A087')
            UnitMakeAbilityPermanent(hero, true, 'A0R8')
            //maphack.InitHero(hero)
            if IsUnitAlly(hero, Player(10)) then
                GroupAddUnit(CG1, hero)
            else
                GroupAddUnit(CG3, hero)
            endif
            //给Lua的hook
            UnitW##akeUp(hero)
            //发起英雄注册事件
            Event.HeroInit_Start(hero)
        }

        //截取新建单位的阴影图像
        static image Image = null

        static void hookImage(){
            Image = CreateImage("Shadow", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
            DestroyImage(Image)
        }

        //带反全图的创建单位
        static group CreateNUnitsAtLoc2(integer count, integer unitId, player whichPlayer, location loc, real face){
            GroupClear(bj_lastCreatedGroup)
            loop
                count --
                exitwhen count < 0
                hookImage()
                bj_lastCreatedUnit = CreateUnitAtLoc(whichPlayer, unitId, loc, face)
                maphack.InitHero(bj_lastCreatedUnit)
                GroupAddUnit(bj_lastCreatedGroup, bj_lastCreatedUnit)
            endloop
            return bj_lastCreatedGroup
        }

        //游戏开始
        static void AfterSP(){
            maphack.AfterSP()
        }

        //闪电效果
        static lightning AddLightningEx2(string name, bool check, real x1, real y1, real z1, real x2, real y2, real z2){
            if check and not IsPlayerObserver(sys.selfp) and not IsVisibleToPlayer(x1, y1, sys.selfp) and not IsVisibleToPlayer(x2, y2, sys.selfp) then
                return AddLightningEx(name, false, 0, 0, 1000000, 0, 0, 1000000)
            else
                return AddLightningEx(name, false, x1, y1, z1, x2, y2, z2)
            endif
        }

        static bool MoveLightningEx2(lightning whichBolt, boolean checkVisibility, real x1, real y1, real z1, real x2, real y2, real z2){
            if checkVisibility and not IsPlayerObserver(sys.selfp) and not IsVisibleToPlayer(x1, y1, sys.selfp) and not IsVisibleToPlayer(x2, y2, sys.selfp) then
                return MoveLightningEx(whichBolt, false, 0, 0, 1000000, 0, 0, 1000000)
            else
                return MoveLightningEx(whichBolt, false, x1, y1, z1, x2, y2, z2)
            endif
        }

        #define AddLightningEx(s, b, x1, y1, z1, x2, y2, z2) baka.AddLightningEx2(s, b, x1, y1, z1, x2, y2, z2)
        #define MoveLightningEx(l, b, x1, y1, z1, x2, y2, z2) baka.MoveLightningEx2(l, b, x1, y1, z1, x2, y2, z2)

        //可破坏物是否是树(通过ID枚举)
        <?
            local all_ids   = table.back {'B002', 'YTfb', 'B003', 'YTpb', 'ATtc', 'BTtc', 'ATtr', 'BTtw', 'ZTg1', 'FTtw', 'B004', 'CTtc', 'YT11', 'BTsc', 'ZTg2', 'CTtr', 'B000', 'LT06', 'LTrc', 'YTpc'}
            local ids       = {}

            for _, id in ipairs(all_ids) do
            if slk.destructable[id].Name:match '树' then
                table.insert(ids, ("id == '%s'"):format(id))
            end
            end

            local push      = table.concat(ids, ' or ')
        ?>

        static bool IsDestructableWood(destructable des){
            int id  = GetDestructableTypeId(des)
            return <?=push?>
        }
    endstruct

    private void Init(){
        baka.InitSP()
        maphack.InitS()

        TimerStart(CreateTimer(), 0.1, true, function baka.CheckVisible)
        //单位被召唤时,加入检测
        trigger trg = CreateTrigger()
        TriggerRegisterAnyUnitEventBJ(trg, EVENT_PLAYER_UNIT_SUMMON)
        TriggerAddCondition(trg, Condition(function baka.CheckSummon))
        //召唤单位死亡时,取出检测
        TriggerAddCondition(baka.CheckDeath, Condition(function baka.SummonDeath))
        //
        trg = null
    }
endlibrary
########
########
//TESH.scrollpos=253
//TESH.alwaysfold=0
library unitLibrary initializer Init needs bakaLibrary

    struct Unit
        /*
        替换单位物品栏中的物品
        注意替换过程中换多次触发单位获得/失去物品事件
        单位处于无法拾取物品的状态时会替换失败
        */
        static void ExchangeItem(unit luu, int ItemID1, int ItemID2, bool b1, bool b2){
            int i1 = 0
            int i2 = 0
            int a1
            int a2
            real a3
            item lii
            item li2
            int playerid
            loop
                exitwhen i1 > 5
                lii = UnitItemInSlot(luu,i1)
                if GetItemTypeId(lii) == ItemID1 then
                    a1 = GetItemUserData(lii)
                    a2 = GetItemCharges(lii)
                    a3 = GetWidgetLife(lii)
                    playerid = GetPlayerId(GetItemPlayer(lii))
                    RemoveItem(lii)
                    loop
                        exitwhen i2 > i1 - 1
                        if UnitItemInSlot(luu, i2) == null then
                            UnitAddItem(luu, CreateItem('I02S', GetUnitX(luu), GetUnitY(luu)))
                        endif
                        i2++
                    endloop
                    li2 = CreateItem(ItemID2,-7220, 7115)
                    UnitAddItem(luu, li2)
                    if b1
                        SetItemUserData( li2, a1 )
                    endif
                    if b2
                        SetItemCharges( li2, a2 )
                    endif
                    SetWidgetLife( li2, a3 )
                    SetItemPlayer(li2,Player(playerid),false)
                    i2 = 0
                    loop
                        exitwhen i2 > i1 - 1
                        lii = UnitItemInSlot(luu, i2)
                        if GetItemTypeId(lii) == 'I02S' then
                            RemoveItem( lii )
                        endif
                        i2++
                    endloop
                endif
                i1++
            endloop
            lii = null
            li2 = null
        }

        /*
        令(单位)向(方向)移动(距离)
        单位移动速度为0则不作动作(否则可能会灵肉分离)
        */
        static bool MoveSuccess = false
        static real lastMoveDis = 0

        static bool Move(unit u,real a,real r){
            if GetUnitMoveSpeed(u) == 0
                return false
            endif
            real x = LoadReal(YDHT, GetHandleId(u), StringHash("移动干涉"))
            lastMoveDis = r + r * x / 100
            SetUnitX(u, YDWECoordinateX((GetUnitX(u) + (lastMoveDis * Cos(bj_DEGTORAD * a)))))
            SetUnitY(u, YDWECoordinateY((GetUnitY(u) + (lastMoveDis * Sin(bj_DEGTORAD * a)))))
            return true
        }

        static bool Move2(unit u,real a,real r, pathingtype t){
            if GetUnitMoveSpeed(u) == 0
                return false
            endif
            real x = LoadReal(YDHT, GetHandleId(u), StringHash("移动干涉"))
            lastMoveDis = r + r * x / 100
            real x0 = GetUnitX(u)
            real y0 = GetUnitY(u)
            real x1 = x0 + (lastMoveDis * Cos(bj_DEGTORAD * a))
            real y1 = y0 + (lastMoveDis * Sin(bj_DEGTORAD * a))
            if not IsTerrainPathable(x1, y1, t) then
                SetUnitX(u, x1)
                SetUnitY(u, y1)
                return true
            elseif not IsTerrainPathable(x1, y0, t) then
                SetUnitX(u, x1)
                SetUnitY(u, y0)
            elseif not IsTerrainPathable(x0, y1, t) then
                SetUnitX(u, x0)
                SetUnitY(u, y1)
            endif
            return false
        }

        define <call Unit.Move> = {set Unit.MoveSuccess = Unit.Mo##ve}
        define <call Unit.Move2> = {set Unit.MoveSuccess = Unit.Mo##ve2}

        /*
        设置单位的XY坐标
        */
        static void SetUnitXY(unit u, real x, real y){
            SetUnitX(u, YDWECoordinateX(x))
            SetUnitY(u, YDWECoordinateY(y))
        }

        static void SetUnitXYOffset(unit u, real x, real y, real a, real r){
            x = x + r * Cos(bj_DEGTORAD * a)
            y = y + r * Sin(bj_DEGTORAD * a)
            SetUnitX(u, YDWECoordinateX(x))
            SetUnitY(u, YDWECoordinateY(y))
        }

        /*
        创建多个单位(点)
        自动清除引用点
        */
        static group CreateNUnitsAtLocMU(integer count, integer unitId, player whichPlayer, location loc, real face){
            call GroupClear(bj_lastCreatedGroup)
            loop
                set count = count - 1
                exitwhen count < 0
                set bj_lastCreatedUnit = CreateUnitAtLoc(whichPlayer, unitId, loc, face)
                call GroupAddUnit(bj_lastCreatedGroup, bj_lastCreatedUnit)
            endloop
            call RemoveLocation(loc)
            return bj_lastCreatedGroup
        }

        /*
        创建单位(点)
        自动清除引用点
        */
        static unit CreateUnitAtLocMU(player id, integer unitid, location whichLocation, real face){
            real x = GetLocationX(whichLocation)
            real y = GetLocationY(whichLocation)
            RemoveLocation(whichLocation)
            return CreateUnit(id, unitid, x, y, face)
        }

        /*
        移动单位(点)
        自动清除引用点
        */
        static void SetUnitPositionLocMU(unit u ,location loc){
            SetUnitPositionLoc(u,loc)
            RemoveLocation(loc)
        }

        /*
        选取直线范围内的单位
        */
        static group GetUnitInLineAll(location loc, bool flag, real ang, real len, real dis){
            real x1 = GetLocationX(loc)
            real y1 = GetLocationY(loc)
            if flag then
                RemoveLocation(loc)
            endif
            real x2 = x1 + len * Cos(ang * bj_DEGTORAD)
            real y2 = y1 + len * Sin(ang * bj_DEGTORAD)

            //线段中点
            real x0 = (x1 + x2) / 2
            real y0 = (y1 + y2) / 2

            //直线公式 A*x + B*y + C = 0
            real A = y1 - y2
            real B = x2 - x1
            real C = - A * x1 - B * y1

            //点到线段公式│AXo＋BYo＋C│／√（A^2＋B^2）
            real s = SquareRoot(A * A + B * B)
            if s == 0 then
                s = 1
            endif

            //使用拟合圆进行初步选取
            group g = CreateGroup()
            GroupEnumUnitsInRange(g, x0, y0, len / 2, null)

            //进行逐个精选
            sys.g = CreateGroup()
            loop
                unit u = FirstOfGroup(g)
                exitwhen u == null
                GroupRemoveUnit(g, u)
                //判定距离
                real x = GetUnitX(u)
                real y = GetUnitY(u)
                real d = (A * x + B * y + C) / s
                if d < 0 then
                    d = - d
                endif
                if d < dis then
                    GroupAddUnit(sys.g, u)
                endif
            endloop
            DestroyGroup(g)
            g = null
            return sys.g
        }

        /*
        选取原型范围内的单位(点)
        自动清除引用点
        */
        static group GetUnitsInRangeOfLocMatchingMU(real radius, location whichLocation, boolexpr filter){
            local group g = CreateGroup()
            call GroupEnumUnitsInRangeOfLoc(g, whichLocation, radius, filter)
            call RemoveLocation(whichLocation)
            call DestroyBoolExpr(filter)
            set sys.g = g
            set g = null
            return sys.g
        }

        static group GetUnitsInRangeOfLocAllMU(real radius, location whichLocation){
            return GetUnitsInRangeOfLocMatchingMU(radius,   whichLocation,  Condition( \
                lambda bool(){
                    return not IsUnitType(GetFilterUnit(), UNIT_TYPE_TAUREN)
                } \
            ))
        }

        /*
        添加技能
        */
        static int UnitAddAbilityMU(unit u ,integer id,integer level){
            if id == 0
                UnitRemoveAbility(u, id)
                return 0
            elseif GetUnitAbilityLevel(u, id) == 0
                if not UnitAddAbility(u, id)
                    return 0
                endif
            endif
            UnitMakeAbilityPermanent(u, true, id)
            if GetUnitAbilityLevel(u, id) != level
                SetUnitAbilityLevel(u, id, level)
            endif
            return GetUnitAbilityLevel(u, id)
        }

        /*
        刷新单一技能冷却
        */
        static bool RefreshSkill(unit u,int id){
            int lv=GetUnitAbilityLevel(u,id)
            if lv==0
                return false
            endif
            UnitRemoveAbility(u,id)
            UnitAddAbility(u,id)
            SetUnitAbilityLevel(u,id,lv)
            Event.UnitResetCooldown_Hook(u, id)
            return true
        }

        /*
        暂停单位
        */
        static void PauseUnitMU(unit u, bool b, string flag){
            int key = StringHash("暂停:" + flag)
            int h = GetHandleId(u)
            int count = LoadInteger(YDHT, h, StringHash("全局暂停计数"))
            if b then
                if not LoadBoolean(YDHT, h, key) then
                    SaveBoolean(YDHT, h, key, true)
                    count ++
                    SaveInteger(YDHT, h, StringHash("全局暂停计数"), count)
                    if count == 1 then
                        PauseUnit(u, b)
                        //SaveReal(YDHT, h, StringHash("上次进入暂停的时间"), sys.getTime())
                        SaveUnitHandle(YDHT, StringHash("事件"), StringHash("来源"), u)
                        SaveUnitHandle(YDHT, StringHash("事件"), StringHash("目标"), u)
                        Event.UserEventStart(单位进入暂停状态)
                    endif
                endif
            else
                if LoadBoolean(YDHT, h, key) then
                    SaveBoolean(YDHT, h, key, false)
                    count --
                    SaveInteger(YDHT, h, StringHash("全局暂停计数"), count)
                    if count == 0 then
                        PauseUnit(u, b)
                        //SaveReal(YDHT, h, StringHash("上次离开暂停的时间"), sys.getTime())
                        SaveUnitHandle(YDHT, StringHash("事件"), StringHash("来源"), u)
                        SaveUnitHandle(YDHT, StringHash("事件"), StringHash("目标"), u)
                        Event.UserEventStart(单位离开暂停状态)
                    endif
                endif
            endif
        }

        /*
        单位死亡(宏)
        */
        static bool IsDead(unit u){
            return not UnitAlive(u)
        }

        #define IsUnitDeadBJ(u) Unit.IsDead(u)
        #define IsUnitAliveBJ(u) UnitAlive(u)

        /*
        移除单位
        */
        static unit r_g1[]
        static int r_i1 = 0
        static unit r_g2[]
        static int r_i2 = 0

        static void RemoveLater(unit u){
            r_g1[r_i1] = u
            r_i1 ++
        }

        static void RemoveLater_timer(){
            int i = 0
            loop
                exitwhen i == r_i2
                RemoveUnit(r_g2[i])
                i ++
            endloop
            i = 0
            loop
                exitwhen i == r_i1
                r_g2[i] = r_g1[i]
                i ++
            endloop
            r_i2 = r_i1
            r_i1 = 0
        }

        /*
        马甲攻击
        */
        static void DummyAttack(unit hero, int uid, unit target, int attack_time, bool attack_now, bool hero_state, bool hero_item, bool hero_stop){
            real x1 = GetUnitX(hero)
            real y1 = GetUnitY(hero)
            real x2 = GetUnitX(target)
            real y2 = GetUnitY(target)
            real face = Atan2BJ(y2 - y1, x2 - x1)
            unit dummy = CreateUnit(GetOwningPlayer(hero), uid, GetUnitX(hero), GetUnitY(hero), face)
            //将马甲加入清理组
            FlushUnit_Add(dummy)
            UnitAddType(dummy, UNIT_TYPE_SUMMONED)
            //设置真实来源
            SaveUnitHandle(YDHT, GetHandleId(dummy), StringHash("真实伤害来源"), hero)
            //debug@ BJDebugMsg("<马甲攻击> hero[" + GetUnitName(hero) + "] target[" + GetUnitName(target) + "] dummy[" + GetUnitName(dummy) + "]")
            if IsUnitType(dummy, UNIT_TYPE_HERO) then
                SetHeroLevel(dummy, 99, false)

                //继承英雄属性
                if hero_state then
                    SetHeroStr(dummy, GetHeroStr(hero, false), true)
                    SetHeroInt(dummy, GetHeroInt(hero, false), true)
                    SetHeroAgi(dummy, GetHeroAgi(hero, false), true)
                endif

                //继承英雄装备
                if hero_item then
                    int i = 0
                    item it
                    loop
                        exitwhen i > 5
                        it = CreateItem(GetItemTypeId(UnitItemInSlot(hero, i)), x1, y1)
                        UnitAddItem(dummy, it)
                        i ++
                    endloop
                    it = null
                endif
            endif

            //隐藏单位
            UnitAddAbility(dummy, 'Aloc')
            ShowUnit(dummy, false)

            //限定攻击目标并计数
                trigger attack_trg = CreateTrigger()

                //绑定数据
                    int h = GetHandleId(attack_trg)
                    SaveInteger(YDHT, h, 1, attack_time)
                    SaveUnitHandle(YDHT, h, 2, target)
                    SaveUnitHandle(YDHT, h, 3, dummy)

                TriggerRegisterUnitEvent(attack_trg, dummy, EVENT_UNIT_TARGET_IN_RANGE)
                TriggerRegisterUnitEvent(attack_trg, dummy, EVENT_UNIT_DEATH)
                TriggerRegisterTimerEvent(attack_trg, 10, false)

                //英雄下达其他指令时是否停止
                if hero_stop then
                    TriggerRegisterUnitEvent(attack_trg, hero, EVENT_UNIT_DEATH)
                    TriggerRegisterUnitEvent(attack_trg, hero, EVENT_UNIT_ISSUED_ORDER)
                    TriggerRegisterUnitEvent(attack_trg, hero, EVENT_UNIT_ISSUED_POINT_ORDER)
                    TriggerRegisterUnitEvent(attack_trg, hero, EVENT_UNIT_ISSUED_TARGET_ORDER)
                endif

                TriggerAddCondition(attack_trg, Condition(  \
                    lambda void(){
                        int h = GetHandleId(GetTriggeringTrigger())
                        bool flag = GetTriggerEventId() == EVENT_UNIT_TARGET_IN_RANGE
                        unit dummy = LoadUnitHandle(YDHT, h, 3)

                        //对攻击进行验证
                        if flag then
                            //取出绑定的数据
                            int attack_time = LoadInteger(YDHT, h, 1)
                            unit attack_target = LoadUnitHandle(YDHT, h, 2)
                            unit this_target = GetEventTargetUnit()
                            if attack_target == this_target then

                                //攻击正确的目标
                                attack_time --
                                if attack_time < 0 then

                                    //耗尽攻击次数,移除单位
                                    flag = false
                                else
                                    SaveInteger(YDHT, h, 1, attack_time)
                                endif
                            else
                                flag = false
                            endif

                            //回收
                            attack_target = null
                            this_target = null
                        endif

                        //判断是否该移除攻击马甲
                        if not flag then
                            PauseUnit(dummy, true)
                            RemoveLater(dummy)
                            DestroyTrigger(GetTriggeringTrigger())
                            FlushChildHashtable(YDHT, h)
                        endif

                        dummy = null

                    }   \
                ))

            //是否立刻进行攻击
            if attack_now then
                IssueTargetOrder(dummy, "attack", target)
            endif

            //回收
            bj_lastCreatedUnit = dummy
            dummy = null
            attack_trg = null
        }

        /*
        删除单位组
        */
        define <call Unit.WantDestroyGroup()> = {set bj_wantDestroyGroup = true}

        /*
        马甲放技能(第5个参数在保存地图时通过lua进行设置)
        */
        static unit dummy[]

        //保存地图时根据技能id生成第5个参数
        <?
            update('war3map.j',
                function(content)
                    content = content:gsub("(Unit.DummySkill%a-%(%C+)",
                        function(s)
                            local flag
                            s = s:gsub("(.+')(%w+)(')",
                                function(s1, sid, s3)
                                    flag = true
                                    local ab = slk.ability[sid]
                                    if tonumber(ab.Rng1) < 5000 then
                                        error(('%s[%s]%s(%d)'):format(string.char(188, 188, 196, 220), sid, string.char(181, 196, 202, 169, 183, 168, 190, 224, 192, 235, 204, 171, 182, 204, 193, 203), ab.Rng1))
                                    end
                                    if tonumber(ab.Cost1) ~= 0 then
                                        error(('%s[%s]%s(%d)'):format(string.char(188, 188, 196, 220), sid, string.char(181, 196, 196, 167, 183, 168, 207, 251, 186, 196, 178, 187, 202, 199, 48), ab.Cost1))
                                    end
                                    if tonumber(ab.Cool1) ~= 0 then
                                        error(('%s[%s]%s(%d)'):format(string.char(188, 188, 196, 220), sid, string.char(181, 196, 192, 228, 200, 180, 202, 177, 188, 228, 178, 187, 206, 170, 48), ab.Cool1))
                                    end
                                    if tonumber(ab.Cast1) ~= 0 then
                                        error(('%s[%s]%s(%d)'):format(string.char(188, 188, 196, 220), sid, string.char(181, 196, 202, 169, 183, 168, 202, 177, 188, 228, 178, 187, 202, 199, 48), ab.Cast1))
                                    end
                                    local order_id
                                    if ab.Order == '' then
                                        order_id = ab.YDWEtip:sub(-6, -1)
                                    else
                                        order_id = order2id[ab.Order]
                                    end
                                    return ([[%s%s%s, %s]]):format(s1, sid, s3, order_id)
                                end
                            )
                            if not flag then
                                error(('%s\n%s'):format(string.char(188, 188, 196, 220, 182, 193, 200, 161, 202, 167, 176, 220, 44, 199, 235, 200, 183, 200, 207, 188, 188, 196, 220, 204, 238, 181, 196, 181, 196, 190, 178, 204, 172, 214, 181, 40, 178, 187, 196, 220, 211, 195, 177, 228, 193, 191, 41), s))
                            end
                            return s
                        end
                    )

                    return content
                end
            )
        ?>

        static int DummySkill_lastSkill[]
        static int DummySkill_lastLv[]

        static void DummySkill(player p, unit u, int lv, int sid, int order){
            int i = GetPlayerId(p)
            if sid == DummySkill_lastSkill[i] then
                if lv != DummySkill_lastLv[i] then
                    SetUnitAbilityLevel(dummy[i], sid, lv)
                    DummySkill_lastLv[i] = lv
                endif
            else
                UnitRemoveAbility(dummy[i], DummySkill_lastSkill[i])
                UnitAddAbility(dummy[i], sid)
                if lv != 1 then
                    SetUnitAbilityLevel(dummy[i], sid, lv)
                endif
                DummySkill_lastSkill[i] = sid
                DummySkill_lastLv[i] = lv
            endif
            if IsUnitInvisible(u, p) then
                UnitShareVision(u, p, true)
                IssueTargetOrderById(dummy[i], order, u)
                UnitShareVision(u, p, false)
            else
                IssueTargetOrderById(dummy[i], order, u)
            endif
        }

        static void DummySkillLoc(player p, location loc, bool b, int lv, int sid, int order){
            int i = GetPlayerId(p)
            if sid == DummySkill_lastSkill[i] then
                if lv != DummySkill_lastLv[i] then
                    SetUnitAbilityLevel(dummy[i], sid, lv)
                    DummySkill_lastLv[i] = lv
                endif
            else
                UnitRemoveAbility(dummy[i], DummySkill_lastSkill[i])
                UnitAddAbility(dummy[i], sid)
                if lv != 1 then
                    SetUnitAbilityLevel(dummy[i], sid, lv)
                endif
                DummySkill_lastSkill[i] = sid
                DummySkill_lastLv[i] = lv
            endif
            IssuePointOrderByIdLoc(dummy[i], order, loc)
            if b then
                RemoveLocation(loc)
            endif
        }

        static void DummySkill_Init(){
            int i = 0
            loop
                exitwhen i > 15
                if i != 12 then
                    dummy[i] = CreateUnit(Player(i), 'e010', 0, 0, 0)
                endif
                i ++
            endloop
        }

        /*
        设置单位硬直
        */
        static trigger SetHard_trg = CreateTrigger()

        static void SetHard(unit u, real time){
            int h = GetHandleId(u)
            if time == 0 then
                //解除硬直
                PauseTimer(LoadTimerHandle(YDHT, h, StringHash("硬直计时器")))
                SaveBoolean(YDHT, h, StringHash("是否处于硬直状态"), false)
                UnitRemoveAbility(u, 'B02O')
            else
                if GetUnitAbilityLevel(u, 'B02O') == 0 and GetUnitAbilityLevel(u, 'BPSE') == 0 then
                    Unit.DummySkill(GetOwningPlayer(u), u, 1, 'A0PY')
                endif

                if not LoadBoolean(YDHT, h, StringHash("已注册硬直事件")) then
                    SaveBoolean(YDHT, h, StringHash("已注册硬直事件"), true)
                    TriggerRegisterUnitEvent(SetHard_trg, u, EVENT_UNIT_DAMAGED)
                    TriggerRegisterUnitEvent(SetHard_trg, u, EVENT_UNIT_ISSUED_ORDER)
                    TriggerRegisterUnitEvent(SetHard_trg, u, EVENT_UNIT_ISSUED_POINT_ORDER)
                    TriggerRegisterUnitEvent(SetHard_trg, u, EVENT_UNIT_ISSUED_TARGET_ORDER)
                endif

                timer t = LoadTimerHandle(YDHT, h, StringHash("硬直计时器"))
                if t == null then
                    t = CreateTimer()
                    SaveTimerHandle(YDHT, h, StringHash("硬直计时器"), t)
                    SaveUnitHandle(YDHT, GetHandleId(t), 0, u)
                endif
                SaveBoolean(YDHT, h, StringHash("是否处于硬直状态"), true)

                int th = GetHandleId(t)
                TimerStart(t, time, false, \
                    lambda void(){
                        int th = GetHandleId(GetExpiredTimer())
                        unit u = LoadUnitHandle(YDHT, th, 0)
                        int h = GetHandleId(u)
                        SaveBoolean(YDHT, h, StringHash("是否处于硬直状态"), false)
                        UnitRemoveAbility(u, 'B02O')
                        u = null
                    }\
                )
                if LoadInteger(YDHT, h, StringHash("全局暂停计数")) != 0 then
                    PauseTimer(t)
                endif
                t = null
            endif
        }

        static void SetHard_Init(){
            TriggerAddCondition(SetHard_trg, Condition(\
                lambda void(){
                    if GetTriggerEventId() != EVENT_UNIT_DAMAGED or GetEventDamage() == 0 then
                        unit u = GetTriggerUnit()
                        int h = GetHandleId(u)
                        if LoadBoolean(YDHT, h, StringHash("是否处于硬直状态")) and GetUnitAbilityLevel(u, 'B02O') == 0 and GetUnitAbilityLevel(u, 'BPSE') == 0 then
                            DisableTrigger(GetTriggeringTrigger())
                            PauseUnit(u, true)
                            PauseUnit(u, false)
                            Unit.DummySkill(GetOwningPlayer(u), u, 1, 'A0PY')
                            EnableTrigger(GetTriggeringTrigger())
                        endif
                        u = null
                    endif
                } \
            ))

            trigger trg = CreateTrigger()
            Event.UserEventInit(trg, 单位进入暂停状态)
            Event.UserEventInit(trg, 单位离开暂停状态)
            TriggerAddCondition(trg, Condition(\
                lambda void(){
                    unit u  = LoadUnitHandle(YDHT, StringHash("事件"), StringHash("来源"))
                    int h   = GetHandleId(u)
                    if LoadBoolean(YDHT, h, StringHash("是否处于硬直状态")) then
                        timer t = LoadTimerHandle(YDHT, h, StringHash("硬直计时器"))
                        if LoadStr(YDHT, StringHash("事件"), StringHash("名称")) == "单位进入暂停状态" then
                            PauseTimer(t)
                        else
                            TimerStart(t, TimerGetRemaining(t), false, \
                                lambda void(){
                                    int th = GetHandleId(GetExpiredTimer())
                                    unit u = LoadUnitHandle(YDHT, th, 0)
                                    int h = GetHandleId(u)
                                    SaveBoolean(YDHT, h, StringHash("是否处于硬直状态"), false)
                                    UnitRemoveAbility(u, 'B02O')
                                    u = null
                                }\
                            )
                        endif
                    endif
                    u = null
                } \
            ))
            trg = null
        }

        static bool IsHard(unit u){
            return LoadBoolean(YDHT, GetHandleId(u), StringHash("是否处于硬直状态")) or GetUnitAbilityLevel(u, 'B02O') == 1
        }

        /*
        设置单位可以飞行(宏)
        */
        static void FlyEnable(unit u){
            UnitAddAbility(u, 'Arav')
            UnitRemoveAbility(u, 'Arav')
        }

        #define YDWEFlyEnable(u) Unit.FlyEnable(u)

        /*
        创建技能施法进度条
        */
        static unit lastSkillBar = null

        static void SkillBar_Dead(unit bar, bool out){
            if not out then
                RemoveUnit(bar)
                return
            endif

            timer t = CreateTimer()
            int h   = GetHandleId(t)

            SaveUnitHandle(YDHT, h, 0, bar)
            SaveInteger(YDHT, h, 0, 255)
            TimerStart(t, 0.05, true,\
                lambda void(){
                    int h       = GetHandleId(GetExpiredTimer())
                    unit bar    = LoadUnitHandle(YDHT, h, 0)
                    int a       = LoadInteger(YDHT, h, 0)

                    a -= 10
                    SetUnitVertexColor(bar, 255, 255, 255, a)

                    if a <= 0 then
                        DestroyTimer(GetExpiredTimer())
                        FlushChildHashtable(YDHT, h)
                    else
                        SaveInteger(YDHT, h, 0, a)
                    endif

                    bar = null
                }\
            )
            t   = null
        }

        static unit SkillBar(unit hero, real time, playercolor color, bool pause, bool die, bool stop, bool out){
            unit bar    = CreateUnit(GetOwningPlayer(hero), 'e06I', GetUnitX(hero), GetUnitY(hero), 0)
            timer t     = CreateTimer()
            int h       = GetHandleId(t)
            real scale  = 1 / time
            int order   = GetUnitCurrentOrder(hero)

            SetUnitColor(bar, color)

            if time > 0 then
                SetUnitAnimation(bar, "birth")
            else
                SetUnitAnimation(bar, "attack")
                time    = - time
                scale   = - scale
            endif

            SetUnitTimeScale(bar, scale)

            //开始循环计时
            SaveUnitHandle(YDHT, h, 0, bar)
            SaveUnitHandle(YDHT, h, 1, hero)
            SaveBoolean(YDHT, h, 1, pause)
            SaveBoolean(YDHT, h, 2, die)
            SaveBoolean(YDHT, h, 3, stop)
            SaveBoolean(YDHT, h, 4, out)
            SaveReal(YDHT, h, 0, time)
            SaveReal(YDHT, h, 1, scale)
            SaveInteger(YDHT, h, 0, order)

            TimerStart(t, 0.03, true,\
                lambda void (){
                    int h       = GetHandleId(GetExpiredTimer())
                    unit bar    = LoadUnitHandle(YDHT, h, 0)
                    unit hero   = LoadUnitHandle(YDHT, h, 1)
                    bool pause  = LoadBoolean(YDHT, h, 1)
                    bool die    = LoadBoolean(YDHT, h, 2)
                    bool stop   = LoadBoolean(YDHT, h, 3)
                    bool out    = LoadBoolean(YDHT, h, 4)
                    real time   = LoadReal(YDHT, h, 0)
                    real scale  = LoadReal(YDHT, h, 1)
                    real order  = LoadInteger(YDHT, h, 0)
                    if IsUnitType(bar, UNIT_TYPE_DEAD) or (die and IsUnitType(hero, UNIT_TYPE_DEAD)) or (stop and order != GetUnitCurrentOrder(hero)) then
                        SetUnitTimeScale(bar, 0)
                        KillUnit(bar)
                        SkillBar_Dead(bar, out)
                        DestroyTimer(GetExpiredTimer())
                        FlushChildHashtable(YDHT, h)

                        trigger trg = LoadTriggerHandle(YDHT, GetHandleId(bar), StringHash("技能失败"))
                        if trg != null then
                            if IsTriggerEnabled(trg) and TriggerEvaluate(trg) then
                                TriggerExecute(trg)
                            endif
                            FlushChildHashtable(YDHT, GetHandleId(trg))
                            DestroyTrigger(trg)
                            trg = null
                        endif

                        trg = LoadTriggerHandle(YDHT, GetHandleId(bar), StringHash("技能成功"))
                        if trg != null then
                            FlushChildHashtable(YDHT, GetHandleId(trg))
                            DestroyTrigger(trg)
                            trg = null
                        endif

                        FlushChildHashtable(YDHT, GetHandleId(bar))
                    elseif pause and IsUnitPaused(hero) then
                        SetUnitTimeScale(bar, 0)
                        PauseUnit(bar, true)
                    else
                        if IsUnitPaused(bar) then
                            SetUnitTimeScale(bar, scale)
                            PauseUnit(bar, false)
                        endif
                        SetUnitX(bar, GetUnitX(hero))
                        SetUnitY(bar, GetUnitY(hero))
                        SetUnitFlyHeight(bar, 225 + maphack.GetHeight(hero), 0)
                        time -= 0.03
                        if time <= 0 then
                            SetUnitTimeScale(bar, 0)
                            KillUnit(bar)
                            SkillBar_Dead(bar, out)
                            DestroyTimer(GetExpiredTimer())
                            FlushChildHashtable(YDHT, h)

                            trigger trg = LoadTriggerHandle(YDHT, GetHandleId(bar), StringHash("技能成功"))
                            if trg != null then
                                if IsTriggerEnabled(trg) and TriggerEvaluate(trg) then
                                    TriggerExecute(trg)
                                endif
                                FlushChildHashtable(YDHT, GetHandleId(trg))
                                DestroyTrigger(trg)
                                trg = null
                            endif

                            trg = LoadTriggerHandle(YDHT, GetHandleId(bar), StringHash("技能失败"))
                            if trg != null then
                                FlushChildHashtable(YDHT, GetHandleId(trg))
                                DestroyTrigger(trg)
                                trg = null
                            endif

                            FlushChildHashtable(YDHT, GetHandleId(bar))
                        else
                            SaveReal(YDHT, h, 0, time)
                        endif
                    endif

                    bar = null
                    hero = null
                }\
            )

            lastSkillBar = bar
            t = null
            bar = null

            return lastSkillBar
        }

        static void AddMoveSpeed(unit u, real r){
            int h       = GetHandleId(u)
            real ms0    = GetUnitDefaultMoveSpeed(u)
            real ms1    = LoadReal(YDHT, h, StringHash("额外移动速度")) + r
            SaveReal(YDHT, h, StringHash("额外移动速度"), ms1)
            SetUnitMoveSpeed(u, ms0 + ms1)
        }

        /*
        单位的Z轴高度
        */
        static location z_location  = Location(0, 0)

        static real GetUnitZ(unit u){
            MoveLocation(z_location, GetUnitX(u), GetUnitY(u))
            return GetLocationZ(z_location) + GetUnitFlyHeight(u)
        }

        static void SetUnitZ(unit u, real z){
            MoveLocation(z_location, GetUnitX(u), GetUnitY(u))
            SetUnitFlyHeight(u, z - GetLocationZ(z_location), 0)
        }

        //获取单位护甲值
        static real GetUnitDefence(unit u){
            if sys.isIn11() then
                return GetUnitState(u, ConvertUnitState(0x20))
            endif

            //伤害测试法算护甲
            real hp0 = GetWidgetLife(u)
            SetWidgetLife(u, hp0 + 10)
            real hp1 = GetWidgetLife(u)

            //关掉伤害系统
            Event.damageEvent_Enable = false

            //造成测试伤害
            UnitDamageTarget(u, u, 10, false, false, ATTACK_TYPE_CHAOS, DAMAGE_TYPE_NORMAL, WEAPON_TYPE_WHOKNOWS)

            //重新打开伤害系统
            Event.damageEvent_Enable = true

            real hp2 = GetWidgetLife(u)

            //恢复生命值
            SetWidgetLife(u, hp1)

            //算出伤害
            real dam = hp1 - hp2
            if dam <= 0 then
                return 0.
            endif

            //找到护甲免伤参数
            <?
                update('war3mapmisc.txt',
                    function(content)
                        DEF_ARMOR = content:match 'DefenseArmor%=(%C+)'
                    end
                )

            ?>

            //求出护甲值
            return (10. / dam - 1) / <?=DEF_ARMOR?>
        }

        /*
        脚本发布指令
        */

        //是否是脚本下达的指令
        static bool IsOrderedByScript = false

        /*
        发布命令(指定目标)
        */

        static bool IssueTargetOrder2(unit u, string o, unit t){
            bool b
            IsOrderedByScript = true
            if GetUnitAbilityLevel(u, 'Aloc') == 1 then
                player p = GetOwningPlayer(u)
                if IsUnitInvisible(t, p) then
                    UnitShareVision(t, p, true)
                    b = IssueTargetOrder(u, o, t)
                    UnitShareVision(t, p, false)
                    p = null
                else
                    b = IssueTargetOrder(u, o, t)
                endif
                p = null
            else
                b = IssueTargetOrder(u, o, t)
            endif
            IsOrderedByScript = false
            return b
        }

        static bool IssueTargetOrderById2(unit u, integer o, unit t){
            bool b
            IsOrderedByScript = true
            if GetUnitAbilityLevel(u, 'Aloc') == 1 then
                player p = GetOwningPlayer(u)
                if IsUnitInvisible(t, p) then
                    UnitShareVision(t, p, true)
                    b = IssueTargetOrderById(u, o, t)
                    UnitShareVision(t, p, false)
                    p = null
                 else
                    b = IssueTargetOrderById(u, o, t)
                endif
                p = null
            else
                b = IssueTargetOrderById(u, o, t)
            endif
            IsOrderedByScript = false
            return b
        }

        #define IssueTargetOrder(u, o, t) Unit.IssueTargetOrder2(u, o, t)
        #define IssueTargetOrderBJ(u, o, t) Unit.IssueTargetOrder2(u, o, t)
        #define IssueTargetOrderById(u, o, t) Unit.IssueTargetOrderById2(u, o, t)

        /*
        发布命令(坐标点)
        */

        static bool IssuePointOrder2(unit u, string o, real x, real y){
            IsOrderedByScript = true
            bool b = IssuePointOrder(u, o, x, y)
            IsOrderedByScript = false
            return b
        }

        static bool IssuePointOrderById2(unit u, int o, real x, real y){
            IsOrderedByScript = true
            bool b = IssuePointOrderById(u, o, x, y)
            IsOrderedByScript = false
            return b
        }

        #define IssuePointOrder(u, o, x, y) Unit.IssuePointOrder2(u, o, x, y)
        #define IssuePointOrderById(u, o, x, y) Unit.IssuePointOrderById2(u, o, x, y)

        /*
        发布命令(点)
        */

        static bool IssuePointOrderLoc2(unit u, string o, location l){
            IsOrderedByScript = true
            bool b = IssuePointOrderLoc(u, o, l)
            IsOrderedByScript = false
            return b
        }

        static bool IssuePointOrderByIdLoc2(unit u, int o, location l){
            IsOrderedByScript = true
            bool b = IssuePointOrderByIdLoc(u, o, l)
            IsOrderedByScript = false
            return b
        }

        #define IssuePointOrderLoc(u, o, l) Unit.IssuePointOrderLoc2(u, o, l)
        #define IssuePointOrderLocBJ(u, o, l) Unit.IssuePointOrderLoc2(u, o, l)
        #define IssuePointOrderByIdLoc(u, o, l) Unit.IssuePointOrderByIdLoc2(u, o, l)

        /*
        发布命令(点)
        自动清除引用点
        */
        static bool IssuePointOrderLocMU(unit u, string id, location loc){
            IsOrderedByScript = true
            local boolean result = IssuePointOrderLoc(u,id,loc)
            RemoveLocation(loc)
            IsOrderedByScript = false
            return result
        }

        static bool IssuePointOrderByIdLocMU(unit u, integer id, location loc){
            IsOrderedByScript = true
            local boolean result = IssuePointOrderByIdLoc(u,id,loc)
            RemoveLocation(loc)
            IsOrderedByScript = false
            return result
        }

        /*
        发布命令(无目标)
        */
        static bool IssueImmediateOrder2(unit u, string o){
            IsOrderedByScript = true
            bool b = IssueImmediateOrder(u, o)
            IsOrderedByScript = false
            return b
        }

        static bool IssueImmediateOrderById2(unit u, int o){
            IsOrderedByScript = true
            bool b = IssueImmediateOrderById(u, o)
            IsOrderedByScript = false
            return b
        }

        #define IssueImmediateOrder(u, o) Unit.IssueImmediateOrder2(u, o)
        #define IssueImmediateOrderBJ(u, o) Unit.IssueImmediateOrder2(u, o)
        #define IssueImmediateOrderById(u, o) Unit.IssueImmediateOrderById2(u, o)

    endstruct

    private void Init(){
        TimerStart(CreateTimer(), GetRandomInt(30, 60), true, function Unit.RemoveLater_timer)

        Unit.DummySkill_Init()
        Unit.SetHard_Init()
    }
endlibrary
########
########
//TESH.scrollpos=-1
//TESH.alwaysfold=0
library itemLibrary initializer Init needs baseLibrary

    struct Item
        static item it = null

        static void Formula(int id, int id0, int id1, int id2, int id3, int id4, int id5, int id6, int gold){
        }

        static bool UnitHasItemOfTypeBJ2(unit u, int id){
            if id == 0 then
                return false
            endif
            int i = 0
            if GetTriggerEventId() == EVENT_PLAYER_UNIT_DROP_ITEM or GetTriggerEventId() == EVENT_UNIT_DROP_ITEM then
                //如果是在丢弃物品事件中检查,则忽略正在被丢弃的物品
                loop
                    it = UnitItemInSlot(u, i)
                    if GetItemTypeId(it) == id and it != GetManipulatedItem() then
                        return true
                    endif
                    i ++
                    if i > 5 then
                        return false
                    endif
                endloop
            else
                loop
                    if GetItemTypeId(UnitItemInSlot(u, i)) == id then
                        return true
                    endif
                    i ++
                    if i > 5 then
                        return false
                    endif
                endloop
            endif
            return false
        }

        #define UnitHasItemOfTypeBJ(u, id) Item.UnitHasItemOfTypeBJ2(u, id)
        #define YDWEUnitHasItemOfTypeBJNull(u, id) Item.UnitHasItemOfTypeBJ2(u, id)

        static int GetUnitItemCountByType(unit u, int iid){
            int count   = 0
            int i       = 0
            loop
                if GetItemTypeId(UnitItemInSlot(u, i)) == iid then
                    count ++
                endif
                i ++
                exitwhen i > 5
            endloop
            return count
        }
    endstruct

    private void Init(){
    }
endlibrary
########
########
//TESH.scrollpos=-1
//TESH.alwaysfold=0
library textLibrary initializer Init needs baseLibrary
    struct text

        /*
        整合漂浮文字
        为(玩家)的(单位)创建漂浮文字(文字内容),(大小),颜色为(红,绿,蓝),(透明度),(移动速度,移动方向),(永久性),在(淡化点)到(消逝)点之间淡化消逝,(可见性)
        可以被"最后创建的漂浮文字"捕捉
        */
        static void CreateText(player p, unit luu, string str, real size, real red, real green, real blue, real see, real speed, real angle, boolean permanent,real fadepoint, real lifespan, integer showTo){
            set bj_lastCreatedTextTag = CreateTextTag()
            call SetTextTagText(bj_lastCreatedTextTag, str, size * 0.023 / 10)
            call SetTextTagPosUnit(bj_lastCreatedTextTag, luu, 0)
            call SetTextTagColor(bj_lastCreatedTextTag, R2I(red * 2.55), R2I(green * 2.55), R2I(blue * 2.55), R2I((100.0 - see) * 2.55))
            call SetTextTagVelocity(bj_lastCreatedTextTag, speed * 0.071 * Cos(angle * bj_DEGTORAD)/ 128, speed * 0.071 * Sin(angle * bj_DEGTORAD)/ 128)
            call SetTextTagPermanent( bj_lastCreatedTextTag, permanent )
            call SetTextTagFadepoint( bj_lastCreatedTextTag, fadepoint )
            call SetTextTagLifespan( bj_lastCreatedTextTag, lifespan )
            if showTo == 1 then
                if IsPlayerEnemy(p, GetLocalPlayer()) then
                    call SetTextTagVisibility(bj_lastCreatedTextTag, false)
                endif
            elseif showTo == 2 then
                if p != GetLocalPlayer() then
                    call SetTextTagVisibility(bj_lastCreatedTextTag, false)
                endif
            endif
        }
    endstruct

    private void Init(){
    }
endlibrary
########
########
//TESH.scrollpos=-1
//TESH.alwaysfold=0
library effectLibrary initializer Init needs baseLibrary

    struct Effect
        /*
        创建并删除特效
        自动清除引用点
        */
        static void TempEffect(location where, string modelName, bool b){
            DestroyEffect(AddSpecialEffectLoc(modelName,where))
            if b
                RemoveLocation(where)
            endif
        }

        /*
        新建特效
        */
        static effect AddSpecialEffectLoc2(string s, location loc){
            real x = GetLocationX(loc)
            real y = GetLocationY(loc)
            RemoveLocation(loc)
            return AddSpecialEffect(s, x, y)
        }

        define <Effect.AddSpecialEffectLocMU>(a, b) = Effect.AddSpecialEffectLoc2(b, a)
    endstruct

    private void Init(){
    }
endlibrary
########
########
//TESH.scrollpos=-1
//TESH.alwaysfold=0
library soundLibrary initializer Init needs baseLibrary
    struct Sound
        /*
        在 (x,y,z) 播放 (路径名) ,播放速率,是否循环, 是否截断,淡入,淡出,最小衰减范围,最大衰减范围,截断距离
        */
        /*
        private static hashtable HT = InitHashtable()

        static sound play(real x, real y, real z,sound s, real pitch, bool looping, bool stopwhenoutofrange, int fadeInRate, int fadeOutRate, real minDist, real maxDist, real cutoff){
            int k = GetHandleId(s)
            int i = 0
            string name = LoadStr(HT, k, 0)
            real r = GetSoundFileDuration(name) * 0.001
            bj_lastPlayedSound = null
            loop
                exitwhen bj_lastPlayedSound != null
                sound ss = LoadSoundHandle(HT, k, i)
                if ss == null
                    bj_lastPlayedSound = CreateSou##nd(name, looping, true, stopwhenoutofrange, fadeInRate, fadeOutRate, "")
                    SaveSoundHandle(HT, k, i, bj_lastPlayedSound)
                elseif sys.getTime() > LoadReal(HT, k, i)
                    bj_lastPlayedSound = ss
                endif
                i++
            endloop
            SaveReal(HT, k, i-1, sys.getTime() + r)
            SetSoundPosition(bj_lastPlayedSound, x, y, z)
            SetSoundPitch(bj_lastPlayedSound, pitch)
            SetSoundDistances(bj_lastPlayedSound, minDist, maxDist)
            SetSoundDistanceCutoff(bj_lastPlayedSound, cutoff)
            StartSound(bj_lastPlayedSound)
            return bj_lastPlayedSound
        }

        static sound SaveSound(string filename, boolean looping, boolean is3D, boolean stopwhenoutofrange, integer fadeInRate, integer fadeOutRate, string eaxSetting){
            bj_lastPlayedSound = CreateSou##nd(filename, looping, is3D, stopwhenoutofrange, fadeInRate, fadeOutRate, eaxSetting)
            int k = GetHandleId(bj_lastPlayedSound)
            SaveStr(HT,k,0,filename)
            StartSound(bj_lastPlayedSound)
            StopSound(bj_lastPlayedSound, false, false)
            return bj_lastPlayedSound
        }

        */

        static sound CreateSound2(string filename, boolean looping, boolean is3D, boolean stopwhenoutofrange, integer fadeInRate, integer fadeOutRate, string eaxSetting){
            bj_lastPlayedSound = Create##Sound(filename, looping, is3D, stopwhenoutofrange, fadeInRate, fadeOutRate, eaxSetting)
            SetSoundPosition(bj_lastPlayedSound, 0, 0, 0)
            StartSound(bj_lastPlayedSound)
            KillSoundWhenDone(bj_lastPlayedSound)
            return Create##Sound(filename, looping, is3D, stopwhenoutofrange, fadeInRate, fadeOutRate, eaxSetting)
        }

        //define CreateSound = Sound.CreateSound2

        static void SetSoundVolume2(sound s, int i){
            if i > 0 then
                SetSoundVolume(s, i)
            else
                SetSoundVolume(s, 0)
            endif
        }

        #define SetSoundVolume(s, i) Sound.SetSoundVolume2(s, i)

        static void PlaySoundAtPointBJ2(sound soundHandle, real volumePercent, location loc, real z){
            SetSoundPosition(soundHandle, GetLocationX(loc), GetLocationY(loc), z + GetLocationZ(loc))
            SetSoundVolume(soundHandle, PercentToInt(volumePercent, 127))
            PlaySoundBJ(soundHandle)
            RemoveLocation(loc)
        }

        static sound ss[]
        static int s_count = 0
        static timer s_timer = CreateTimer()

        static void KillSound(sound s){
            s_count ++
            ss[s_count] = s
            if s_count == 1 then
                TimerStart(s_timer, 60, false, \
                    lambda void(){
                        int i = 1
                        loop
                            exitwhen i > s_count
                            KillSoundWhenDone(ss[s_count])
                            i ++
                        endloop
                    } \
                )
            endif
        }

        <?
            update('war3map.j',
                function(content)

                    local InitSounds = content:match 'function InitSounds takes nothing returns nothing(.-)endfunction' .. '__end'
                    local sounds = {}

                    InitSounds = InitSounds:gsub('set', '__endset')

                    for v_name, texts in InitSounds:gmatch 'set ([%w_]+)(.-)__end' do
                        sounds[v_name] = texts:gsub('CreateSound', 'Create##Sound')
                        table.insert(sounds, v_name)
                    end

                    content = content:gsub('(StopSound%C+%c+%C+)PlaySound', '%1Play##Sound')

                    content = content:gsub('(%C+PlaySound%w+%( )([%w_]+)(%C+)',
                        function(t1, v_name, t2)
                            local r = ('%s%s%s\ncall Sound.KillSound(%s)\nset %s%s'):format(t1, v_name, t2, v_name, v_name, sounds[v_name])
                            --error(r)
                            return r
                        end
                    )

                    --[=[
                    local codes = {}
                    for i, v_name in ipairs(sounds) do
                        codes[i] = ([[
                            SetSoundPosition(%s, x, y, 0)
                            SetSoundVolume(%s, 0)
                            StartSound(%s)
                        ]]):format(v_name, v_name, v_name)
                    end
                    content = content:gsub('__START_ALL_SOUNDS__', table.concat(codes, '\n'))
                    --]=]

                    return content
                end
            )
        ?>

    endstruct

    private void Init(){
        /*
        TimerStart(CreateTimer(), 0, false,\
            lambda void (){
                DestroyTimer(GetExpiredTimer())
                real x = GetCameraTargetPositionX(), y = GetCameraTargetPositionY()
                __START_ALL_SOUNDS__
            }\
        )
        */
    }
endlibrary

########
########
//TESH.scrollpos=-1
//TESH.alwaysfold=0
library objectLibrary initializer Init needs baseLibrary

    //读取物编数据(lua)
    <?
        --将256位ID转化为整数
        local bj_AllString = ".................................!.#$%&'()*+,-./0123456789:;<=>.@ABCDEFGHIJKLMNOPQRSTUVWXYZ[.]^_`abcdefghijklmnopqrstuvwxyz{|}~................................................................................................................................"

        local ID2I = function(s)
            local ls = string.len(s) --输入字符串的长度
            local result = 0 --结果
            local p = 1 --权重
            for i = ls, 1, -1 do --从最后一位往前依次取值
                local s = string.find(bj_AllString, string.sub(s, i, i))
                result = result + p * s
                p = p * 256
            end
            return result
        end

        --table中是否包含某个值
        table.has = function(t, v)
            for _,i in ipairs(t) do
                if i == v then return true end
                if type(i) == "table" and table.has(i, v) then return true end --如果table中有table,则继续到该table中寻找
            end
        end

        --分割字符串(目标字符串,分割符)
        --返回table
        string.split = function(target, s)
            local result = {} --把结果存在这个table中(返回table)
            local x = 1 --当前字符串的开始位置
            local c = string.len(s) --分割符的长度
            local l = string.len(target) --目标字符串的长度
            for i = 1, l, 1 do --遍历所有字符
                local ss = string.sub(target, i, i+c-1) --当前检查到的字符(分割符长度)
                if ss == s then --如果当前字符为分隔符
                    table.insert(result, string.sub(target, x, i-1)) --把找到的字符串存到table中
                    x = i+c --下个字符串的开始位置移动到当前分割符的右方
                end
            end
            local ss = string.sub(target, x, l)
            if ss then
                l = string.len(ss)
                if l and l > 0 then
                    table.insert(result, ss) --把最后一段字符串加入进去
                end
            end
            return result
        end

        --记录单位类型(字符串形式)
        local heroTypes = {}

        heroTypes[1] = 'Emoo'
        heroTypes[2] = 'Ewar'
        heroTypes[3] = 'Huth'
        heroTypes[4] = 'Ntin'
        heroTypes[5] = 'Hpal'
        heroTypes[6] = 'Hamg'
        heroTypes[7] = 'Hmkg'
        heroTypes[8] = 'Hvwd'
        heroTypes[9] = 'Harf'
        heroTypes[10] = 'Otch'
        heroTypes[11] = 'Edem'
        heroTypes[12] = 'Ewrd'
        heroTypes[13] = 'Udre'
        heroTypes[14] = 'Oshd'
        heroTypes[15] = 'Obla'
        heroTypes[16] = 'Eill'
        heroTypes[17] = 'Orex'
        heroTypes[18] = 'Ofar'
        heroTypes[19] = 'Ekee'
        heroTypes[20] = 'Hblm'
        heroTypes[21] = 'Eevi'
        heroTypes[22] = 'Efur'
        heroTypes[23] = 'Ocbh'
        heroTypes[24] = 'H000'
        heroTypes[25] = 'Osam'
        heroTypes[26] = 'Ulic'
        heroTypes[27] = 'Hkal'
        heroTypes[28] = 'Hmbr'
        heroTypes[29] = 'H006'
        heroTypes[30] = 'Udea'
        heroTypes[31] = 'H00J'
        heroTypes[32] = 'H00L'
        heroTypes[33] = 'H00N'

        --开始查找物编

            --创建物编数据
            local SLK = require("slk"):Create()

            local heroSkills = {} --记录英雄拥有的技能

            --遍历物编数据(单位数据)
            for Id, Obj in SLK.Foreach(SLK.Unit) do
                --Id为单位类型(字符串),例'U001'
                --Obj为table,保存了该ID下的所有数据,以数据项名称为索引

                if table.has(heroTypes, Id) then

                    local result --找到的数据(字符串)

                    --技能
                    result = Obj['heroAbilList']
                    heroSkills[Id] = string.split(result, ",")

                    for _,id in ipairs(string.split(result, ",")) do
                        heroSkills[id] = true
                    end
                end
            end

            local skillCost = {} --记录技能耗蓝
            local skillCool = {} --记录技能冷却
            local skillCommand = {} --记录技能命令ID

            --遍历物编数据(技能数据)
            for Id, Obj in SLK.Foreach(SLK.Ability) do
                --Id为技能类型(字符串),例'A001'
                --Obj为table,保存了该ID下的所有数据,以数据项名称为索引

                if heroSkills[Id] then

                    local result --找到的数据

                    --耗蓝
                    skillCost[Id] = {}
                    for i = 1, 5, 1 do
                        skillCost[Id][i] = tonumber(Obj['Cost' .. i]) or 0 --保存耗蓝
                    end

                    --冷却
                    skillCool[Id] = {}
                    for i = 1, 5, 1 do
                        skillCool[Id][i] = tonumber(Obj['Cool' .. i]) or 0 --保存冷却
                    end

                    --skillCommand[Id] = {}
                    skillCommand[Id] = Obj['Order']
                    if skillCommand[Id] == "channel" then --如果是通魔
                        skillCommand[Id] = Obj['DataF1'] --找基础命令
                    end

                end
            end
    ?>

    struct object
        //哈希表
        static hashtable HT = InitHashtable() //英雄技能
        static int COST = 1
        static int COOL = 2
        static int COMMAND = 0

        //保存数据
        static void saveData(){
            //使用lua将读取的数据保存在哈希表中
            <?--[[
            --汇出数据

                --汇出技能数据
                for _,id in ipairs(heroTypes) do
                    --id为单位类型(字符串)
                    local t = heroSkills[id] --获取英雄的技能列表
                    for i,s in ipairs(t) do --遍历技能列表
                        --i为索引
                        --s为技能类型(字符串)
                        ?>
                        SaveInteger(HT, '<?=id?>', <?=i?>, '<?=s?>') //保存方式(单位类型,索引,技能类型)
                        SaveStr(HT, '<?=s?>', COMMAND, "<?=skillCommand[s]?>") //保存方式(技能类型,0,命令字符)
                        <?
                        for lev, cost in ipairs(skillCost[s]) do
                            ?>
                            SaveReal(HT, '<?=s?>', COST*10 + <?=lev?>, <?=cost?>) //保存方式(技能类型,10+等级,耗蓝)
                            <?
                        end
                        for lev, cool in ipairs(skillCool[s]) do
                            ?>
                            SaveReal(HT, '<?=s?>', COOL*10 + <?=lev?>, <?=cool?>) //保存方式(技能类型,20+等级,冷却)
                            <?
                        end
                    end
                end
            ]]?>
        }

        //获取英雄的技能
        static int getUnitSkillByType(int t, int i){
            return LoadInteger(HT, t, i)
        }

        static int getUnitSkill(unit u, int i){
            return getUnitSkillByType(GetUnitTypeId(u), i)
        }

        //获取技能耗蓝
        static real getSkillCost(int s, int lv){
            return LoadReal(HT, COST*10 + s, lv)
        }

        //获取技能冷却
        static real getSkillCool(int s, int lv){
            return LoadReal(HT, COOL*10 + s, lv)
        }

        //获取技能命令
        static string getSkillCommand(int s){
            return LoadStr(HT, s, COMMAND)
        }
    endstruct

    private void Init(){
    }
endlibrary
########
########
//TESH.scrollpos=123
//TESH.alwaysfold=0
library testLibrary initializer Init needs baseLibrary
    struct test
        static trigger testTrigger = CreateTrigger()
        static bool Enable  = false

        static bool action(){
            string s = GetEventPlayerChatString()
            player p = GetTriggerPlayer()
            if p != Play##er(0) and not test.Enable then
                DisplayTimedTextToPlayer(p, 0, 0, 10, "1楼关闭了测试指令,若需启用请1楼输入 .test")
                p = null
                return false
            endif
            int id = GetPlayerId(p)
            unit hero = udg_player[id + 1]
            String.Split(s, " ")
            s = String.GetStr(1)
            s = StringCase(s, false)
            if s == ".lv" then
                SetHeroLevel(hero, S2I(String.GetStr(2)), true)
            elseif s == ".showid" then
                int i = 0
                BJDebugMsg("[当前ID]" + I2S(GetPlayerId(GetLocalPlayer())) + " / " + I2S(GetHandleId(GetLocalPlayer())))
                loop
                    exitwhen i > 9
                    BJDebugMsg("[" + I2S(i) + ":" + GetPlayerName(Player(i)) + "] → " + I2S(GetPlayerId(Player(i))) + " / " + I2S(GetHandleId(Player(i))))
                    i ++
                endloop
            elseif s == ".hp" then
                SetUnitState(hero, UNIT_STATE_LIFE, 999999)
                SetUnitState(hero, UNIT_STATE_MANA, 999999)
                UnitResetCooldown(hero)
            elseif s == ".move" then
                if sys.selfp == p then
                    StoreInteger(sys.GC, "mx", I2S(id), R2I(GetCameraTargetPositionX()))
                    StoreInteger(sys.GC, "my", I2S(id), R2I(GetCameraTargetPositionY()))
                    SyncStoredInteger(sys.GC, "mx", I2S(id))
                    SyncStoredInteger(sys.GC, "my", I2S(id))
                endif
                StoreInteger(sys.GC, "mx", I2S(id), 0)
                StoreInteger(sys.GC, "my", I2S(id), 0)
                TriggerSleepAction(1)
                real x = GetStoredInteger(sys.GC, "mx", I2S(id))
                real y = GetStoredInteger(sys.GC, "my", I2S(id))
                SetUnitX(hero, x)
                SetUnitY(hero, y)
            elseif s == ".gold" then
                SetPlayerState(p, PLAYER_STATE_RESOURCE_GOLD, 999999999)
            elseif s == ".skill" then
                int sid = YDWES2Id(String.GetStr(2))
                int lv = S2I(String.GetStr(3))
                if GetUnitAbilityLevel(hero, sid) == 0 then
                    UnitAddAbility(hero, sid)
                    SetUnitAbilityLevel(hero, sid, lv)
                    UnitMakeAbilityPermanent(hero, true, sid)
                else
                    if lv == 0 then
                        UnitRemoveAbility(hero, sid)
                    else
                        SetUnitAbilityLevel(hero, sid, lv)
                    endif
                endif
            elseif s == ".pskill" then
                hero = udg_Pet[GetPlayerId(p) + 1]
                int sid = YDWES2Id(String.GetStr(2))
                int lv = S2I(String.GetStr(3))
                if GetUnitAbilityLevel(hero, sid) == 0 then
                    UnitAddAbility(hero, sid)
                    SetUnitAbilityLevel(hero, sid, lv)
                    UnitMakeAbilityPermanent(hero, true, sid)
                else
                    if lv == 0 then
                        UnitRemoveAbility(hero, sid)
                    else
                        SetUnitAbilityLevel(hero, sid, lv)
                    endif
                endif
            elseif s == ".handle" then
                int i = 1
                location loc[]
                loop
                    exitwhen i > 10
                    loc[i] = Location(0, 0)
                    BJDebugMsg("<句柄泄露测试>" + I2S(GetHandleId(loc[i])))
                    i ++
                endloop
                i = 1
                loop
                    exitwhen i > 10
                    RemoveLocation(loc[i])
                    loc[i] = null
                    i ++
                endloop
            elseif s == ".key" then
                if check_timer < 1000 then
                    int key = S2I(String.GetStr(2))
                    int hash = StringHash("2.6H" + sPlayer.GetPlayerBaseName(p) + "呜喵")
                    if key == hash then
                        check_timer = 99999
                        BJDebugMsg("|cffff8888授权码已确认,感谢参与测试,你们的支持是地图发展的动力!|r")
                        BJDebugMsg("|cffff8888本地图保存于<?=os.date('[%Y/%m/%d - %H:%M:%S]')?>,请注意确认版本")
                    endif
                endif
            elseif s == ".ai" then
                AI.Init()
            elseif s == ".mh" then
                unit smd = udg_SmD[id + 1]
                UnitRemoveAbility(smd, 'A0C1')
                UnitAddAbility(smd, 'A0BJ')
                SetUnitAbilityLevel(smd, 'A0BJ', udg_zhengshu2[179] )
                smd = null
            elseif s == ".aid" then
                SetUnitAnimationByIndex(hero, S2I(String.GetStr(2)))
            elseif s == ".neverdead" then
                SaveInteger(YDHT, GetHandleId(hero), StringHash("免疫死亡"), S2I(String.GetStr(2)))
            elseif s == ".damage" then
                UnitDamageTarget(hero, hero, S2R(String.GetStr(2)), false, false, ATTACK_TYPE_CHAOS, DAMAGE_TYPE_UNKNOWN, WEAPON_TYPE_WHOKNOWS)
            elseif s == ".hard" then
                Unit.SetHard(hero, S2R(String.GetStr(2)))
            elseif s == ".getdef" then
                BJDebugMsg(R2S(Unit.GetUnitDefence(hero)))
            elseif s == ".test" then
                if p == Play##er(0) then
                    test.Enable = not test.Enable
                    if test.Enable then
                        BJDebugMsg("测试指令已开启")
                    else
                        BJDebugMsg("测试指令已关闭")
                    endif
                endif
            elseif s == ".dummy" then
                unit u = CreateUnit(Player(12), 'n02H', GetUnitX(hero), GetUnitY(hero), 0)
                int hp = S2I(String.GetStr(2))
                if hp > 0 then
                    YDWEGeneralBounsSystemUnitSetBonus(u, 0, 2, hp )
                endif
                if String.GetStr(3) == "false" then
                    UnitAddAbility(u, 'Abun')
                endif
                u = null
            elseif s == ".pause" then
                if LoadBoolean(YDHT, GetHandleId(hero), StringHash("暂停:测试")) then
                    Unit.PauseUnitMU(hero, false, "测试")
                else
                    Unit.PauseUnitMU(hero, true, "测试")
                endif
            elseif s == ".gamespeed" then
                SetGameSpeed(ConvertGameSpeed(S2I(String.GetStr(2))))
            else
                p = null
                hero = null
                return false
            endif
            BJDebugMsg(GetPlayerName(p) + "使用了测试指令:" + GetEventPlayerChatString())
            p = null
            hero = null
            return false
        }

        static int check_timer = 60

        static void check_func1(){
            if check_timer > 1000 then
                DestroyTimer(GetExpiredTimer())
                return
            endif
            if check_timer > 0 then
                BJDebugMsg("|cffff8888本地图为测试版地图,请输入授权码,否则游戏将在 " + I2S(check_timer) + " 秒后结束|r")
                check_timer -= 10
            else
                BJDebugMsg("|cffff8888测试地图未授权!!!|r")
                PauseAllUnitsBJ(true)
            endif
        }

        static void check(){
            if bj_isSinglePlayer then
                return
            endif
            check_func1()
            TimerStart(CreateTimer(), 10, true, function test.check_func1)
        }

        //重载计时器
        //双向链表结构
        static int      timer_last[]        //上一个索引
        static int      timer_next[]        //下一个索引
        static timer    timer_timer[]       //计时器
        static real     timer_dur[]         //计时器周期
        static real     timer_start_time[]  //计时器启动的时间
        static string   timer_v_name[]      //计时器变量名
        static string   timer_f_name[]      //计时器所在函数名

        static int      timer_idle[]          //空闲索引
        static int      timer_idle_top = 8191   //空闲索引计数

        static void RemoveTimer(timer t){
            int key = LoadInteger(YDHT, StringHash("计时器重载索引"), GetHandleId(t))
            if key == 0 then
                return
            endif
            //将key放回空闲索引
            timer_idle[++ timer_idle_top] = key

            //断开链表
            int last    = timer_last[key]
            int next    = timer_next[key]
            timer_next[last]    = next
            timer_last[next]    = last

            timer_timer[key]    = null

            //清除保存的key
            RemoveSavedInteger(YDHT, StringHash("计时器重载索引"), GetHandleId(t))
        }

        static void Hook_TimerStart(timer t, real r, bool b, code c, string v_name, string f_name){
            TimerStart(t, r, b, c)
            RemoveTimer(t)
            if r > 5 or not b then
                return
            endif

            //取出一个空闲索引
            int key = timer_idle[timer_idle_top --]
            if key == 0 then
                BJDebugMsg("<错误>计时器索引被用完!")
                Lua_hook(sys.selfp, "hook_timer_error")
                return
            endif
            //索引0是保留的,通过索引0访问第一个和最后一个索引
            //int first   = timer_next[0]
            int last    = timer_last[0]
            //自己成为新的最后一个
            timer_last[0]       = key
            timer_next[key]     = 0
            timer_next[last]    = key
            timer_last[key]     = last
            //开始保存数据
            timer_timer[key]    = t
            timer_dur[key]      = r
            timer_start_time[key]   = sys.getTime()
            timer_v_name[key]   = v_name
            timer_f_name[key]   = f_name
            //保存key
            SaveInteger(YDHT, StringHash("计时器重载索引"), GetHandleId(t), key)
        }

        static void Hook_StartTimerBJ(timer t, bool b, real r, string v_name, string f_name){
            bj_lastStartedTimer = t
            Hook_TimerStart(t, r, b, null, v_name, f_name)
        }

        static void Hook_PauseTimer(timer t){
            RemoveTimer(t)
            PauseTimer(t)
        }

        static void Hook_DestroyTimer(timer t){
            RemoveTimer(t)
            DestroyTimer(t)
        }

        static void TimerInit(){
            int i = 0
            loop
                exitwhen i > timer_idle_top
                timer_idle[++ i] = timer_idle_top - i + 1
            endloop

            //循环遍历所有计时器,检查循环时间太长的
            TimerStart(CreateTimer(), 60, true,\
                lambda void (){
                    int key     = 0
                    real time   = sys.getTime()
                    loop
                        key = timer_next[key]
                        exitwhen key == 0
                        real dur    = time - timer_start_time[key]
                        int times   = R2I(dur / timer_dur[key])
                        if times > 1000 and dur > 300 then
                            BJDebugMsg("<警告>计时器 [" + timer_v_name[key] + "] 循环时间超过300秒,已被忽略!!启动函数 [" + timer_f_name[key] + "]")
                            Lua_hook(sys.selfp, "hook_timer_ignore " + I2S(key))
                            RemoveTimer(timer_timer[key])
                        endif
                    endloop
                }\
            )
        }

        #ifndef RELEASE
            #define TimerStart(t, r, b, c) test.Hook_TimerStart(t, r, b, c, `t`, `FUNCNAME`)
            #define StartTimerBJ(t, b, r) test.Hook_StartTimerBJ(t, b, r, `t`, `FUNCNAME`)
            #define PauseTimer(t) test.Hook_PauseTimer(t)
            #define DestroyTimer(t) test.Hook_DestroyTimer(t)

        #endif
    endstruct

    private void Init(){
        int i = 0
        loop
            exitwhen i > 11
            debug@ TriggerRegisterPlayerChatEvent(test.testTrigger, Player(i), "", false)
            i ++
        endloop
        TriggerAddAction(test.testTrigger, function test.action)

        debug@ test.check()
        debug@ test.TimerInit()
    }
endlibrary
########
########
//TESH.scrollpos=-1
//TESH.alwaysfold=0
library processLibrary initializer Init needs baseLibrary
    struct process
		//双向链表
			//结构
			static int keys[]
			static unit us[]
			static string name[]
			static int uper[]
			static bool cover[]
			static bool enable[]
            static trigger trg[]
			//节点
			static int lastkey[]
			static int nextkey[]
			//指向hash序列
			static int hashindex[]

		//哈希
			//索引常量
			static int h_count = 0
			static int h_index[]
			static int h_max = 0

		//函数
			//剔除 单位 优先级小于等于 100 的 名字 过程
			//返回int 剩余过程数量
			static int Cover(unit u, int uper, string name){
				int h = GetHandleId(u)
				int count = 0
				int max = LoadInteger(YDHT, h, h_max)
                int new_max = 0
				int i = 1
                //BJDebugMsg(I2S(max))
				loop
					exitwhen i > max
					int key = LoadInteger(YDHT, h, h_index[i])
					if key != 0 then
                        new_max = i
						if (name == "全部" or .name[key] == name) and uper >= .uper[key] and enable[key] then
                            //debug@ BJDebugMsg("<优先级被剔除> unit:[" + GetUnitName(u) + "] process:[" + .name[key] + "] hashindex:[" + I2S(i) + "] key:[" + I2S(key) + "]")
							enable[key] = false
							SaveInteger(YDHT, h, h_index[i], 0)
                            if trg[key] != null then
                                if TriggerEvaluate(trg[key]) then
                                    TriggerExecute(trg[key])
                                endif
                                FlushChildHashtable(YDHT, GetHandleId(trg[key]))
                                DestroyTrigger(trg[key])
                            endif
						else
                            count ++
						endif
					endif
					i ++
				endloop
                SaveInteger(YDHT, h, h_max, new_max)
                SaveInteger(YDHT, h, h_count, count)
				return count
			}

			//新建 单位 的 名字 过程, 优先级为 100 ,剔除低优先级过程 true
			//返回int key
			static int Create(unit u, string name, int uper, bool cover){
                int key
				//检查是否有更高优先级存在
				int h = GetHandleId(u)
				int max = LoadInteger(YDHT, h, h_max)
				int i = 1
				loop
					exitwhen i > max
					key = LoadInteger(YDHT, h, h_index[i])
					if key != 0 and .name[key] == name and .uper[key] > uper and .cover[key] and enable[key] then
                        //debug@ BJDebugMsg("<有更高优先级存在> unit:[" + GetUnitName(u) + "] process:[" + name + "] hashindex:[" + I2S(i) + "] key:[" + I2S(key) + "]")
						return 0
					endif
					i ++
				endloop
				//剔除低优先级过程
				if cover then
					Cover(u, uper, name)
				endif
				//过程计数
				int count = LoadInteger(YDHT, h, h_count) + 1
                SaveInteger(YDHT, h, h_count, count)
				max = LoadInteger(YDHT, h, h_max)
				if count > max then
					max = count
					SaveInteger(YDHT, h, h_max, max)
				endif
				//创建一个key
				key = 1
				loop
					exitwhen hashindex[key] == 0
					key ++
				endloop
				us[key] = u
				.name[key] = name
				.uper[key] = uper
				.cover[key] = cover
                trg[key] = null
				enable[key] = true
				//在hash里找一个空位插进去
				i = 1
				loop
					exitwhen LoadInteger(YDHT, h, h_index[i]) == 0
					i ++
				endloop
				if i > 100 then
					BJDebugMsg("<未找到空闲过程位> unit:[" + GetUnitName(u) + "] process:[" + name + "] uper:[" + I2S(uper) + "]")
					return 0
				endif
				SaveInteger(YDHT, h, h_index[i], key)
				hashindex[key] = i
				//链接链表
				lastkey[key] = 0
				nextkey[key] = nextkey[0]
				nextkey[0] = key
                //debug@ BJDebugMsg("<新建过程> unit:[" + GetUnitName(u) + "] process:[" + name + "] hashindex:[" + I2S(i) + "] key:[" + I2S(key) + "]")
				return key
			}

            static int lastKey

            define <process.Create2>(a, b, c, d) = {process.lastKey = process.Create(a, b, c, d)}

			//过程 #key 有效
			//返回bool 是否有效
			static bool IsEnable(int key){
				return enable[key]
			}

			//结束过程 #key
			//返回bool 是否有效
			static bool Remove(int key){
                if key == 0 then
                    return false
                endif
				if hashindex[key] == 0 then
                    BJDebugMsg("<试图结束不存在的过程!请截图汇报!>")
                    BJDebugMsg("unit:[" + GetUnitName(us[key]) + "] process:[" + name[key] + "] hashindex:[" + I2S(hashindex[key]) + "] key:[" + I2S(key) + "]")
					return false
				endif
				int h = GetHandleId(us[key])
                if enable[key] then
                    enable[key] = false
                    SaveInteger(YDHT, h, h_index[hashindex[key]], 0)
                endif
                //debug@ BJDebugMsg("<结束过程> unit:[" + GetUnitName(us[key]) + "] process:[" + name[key] + "] hashindex:[" + I2S(hashindex[key]) + "] key:[" + I2S(key) + "]")
				hashindex[key] = 0
				int last = lastkey[key]
				int next = nextkey[key]
				nextkey[last] = next
				lastkey[next] = last
				return true
			}

            //设置过程优先级
            static void SetUper(int key, int uper){
                .uper[key] = uper
            }

            //单位是否拥有某过程
            static bool HasName(unit u, int uper, string name, bool cover_flag, bool enable_flag){
                int key
				int h = GetHandleId(u)
				int max = LoadInteger(YDHT, h, h_max)
				int i = 1
				loop
					exitwhen i > max
					key = LoadInteger(YDHT, h, h_index[i])
					if key != 0 and .name[key] == name and .uper[key] > uper and (.cover[key] or cover_flag) and (enable[key] or enable_flag) then
						return true
					endif
					i ++
				endloop
                return false
            }
	endstruct

	private void Init(){
		int i = 1
		loop
			exitwhen i > 100
			process.h_index[i] = StringHash("过程" + I2S(i))
			i ++
		endloop
        process.h_count = StringHash("过程数量")
        process.h_max = StringHash("过程最大值")
	}
endlibrary
########
########
//TESH.scrollpos=-1
//TESH.alwaysfold=0
library moverLibrary initializer Init needs baseLibrary

    struct Mover
        /*
        设为弹幕
        */
        debug@ static group Mover_debug_group = CreateGroup()

        static void SetMover(unit u){
            real x = GetUnitX(u)
            real y = GetUnitY(u)
            SetUnitPosition(u, x, y)
            //因为绑了数据,所以加入清理组待清理
            FlushUnit_Add(u)

            release@ return
            //检查移动速度
            if GetUnitMoveSpeed(u) == 0 then
                BJDebugMsg("<弹幕>[" + GetUnitName(u) + "]的移动速度不能为0!")
            endif
            if GetUnitAbilityLevel(u, 'Aloc') == 0 then
                BJDebugMsg("<弹幕>[" + GetUnitName(u) + "]必须有蝗虫技能!")
            endif
            if not IsUnitType(u, UNIT_TYPE_ANCIENT) then
                BJDebugMsg("<弹幕>[" + GetUnitName(u) + "]必须有古树类型!")
            endif
            if not IsUnitType(u, UNIT_TYPE_TAUREN) then
                BJDebugMsg("<弹幕>[" + GetUnitName(u) + "]必须有牛头人类型!")
            endif
debug@      GroupEnumUnitsInRange(Mover_debug_group, x, y, 0, null)
debug@      if not IsUnitInGroup(u, Mover_debug_group) then
debug@          BJDebugMsg("<弹幕>[" + GetUnitName(u) + "]选取测试失败!请确认物编中是否有守卫类型!")
debug@      endif
        }

        static void SetStateReal(unit u, int state, real r){
            if state == 1 then
                //在原力场中降低的移动速度
                SaveReal(YDHT, GetHandleId(u), StringHash("原力场-移速降低"), r)
            elseif state == 2 then
                //在原力场中受到的额外斥力
                SaveReal(YDHT, GetHandleId(u), StringHash("原力场-额外斥力"), r)
            endif
        }
    endstruct

    private void Init(){
    }
endlibrary
########
########
//TESH.scrollpos=-1
//TESH.alwaysfold=0
<?
    local function import_hex(filename)
        return function(file_hex)
            file_hex = file_hex:gsub(' ', '')

            local file_content = {}

            for hex in file_hex:gmatch('%d+') do
                table.insert(file_content, hex)
            end

            import(filename)(string.char(table.unpack(file_content)))
        end
    end

    import_hex('Tsukiko.mdx')[[
        077, 068, 076, 088, 086, 069, 082, 083, 004, 000, 000, 000, 032, 003, 000, 000,
        077, 079, 068, 076, 116, 001, 000, 000, 067, 114, 097, 115, 104, 077, 111, 100,
        101, 108, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        029, 090, 013, 194, 017, 071, 013, 194, 181, 149, 012, 194, 029, 090, 013, 066,
        067, 109, 013, 066, 158, 030, 014, 066, 150, 000, 000, 000, 083, 069, 081, 083,
        132, 000, 000, 000, 083, 116, 097, 110, 100, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 077, 001, 000, 000, 134, 002, 000, 000, 000, 000, 000, 000,
        001, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 204, 046, 038, 066,
        029, 090, 013, 194, 017, 071, 013, 194, 181, 149, 012, 194, 029, 090, 013, 066,
        067, 109, 013, 066, 158, 030, 014, 066, 071, 076, 066, 083, 004, 000, 000, 000,
        233, 000, 000, 000, 077, 084, 076, 083, 048, 000, 000, 000, 048, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 076, 065, 089, 083, 001, 000, 000, 000,
        028, 000, 000, 000, 003, 000, 000, 000, 001, 000, 000, 000, 000, 000, 000, 000,
        255, 255, 255, 255, 000, 000, 000, 000, 000, 000, 128, 063, 084, 069, 088, 083,
        012, 001, 000, 000, 000, 000, 000, 000, 082, 101, 112, 108, 097, 099, 101, 097,
        098, 108, 101, 084, 101, 120, 116, 117, 114, 101, 115, 092, 087, 101, 097, 116,
        104, 101, 114, 092, 067, 108, 111, 117, 100, 115, 056, 120, 056, 046, 098, 108,
        112, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        071, 069, 079, 083, 120, 001, 000, 000, 120, 001, 000, 000, 086, 082, 084, 088,
        004, 000, 000, 000, 000, 000, 000, 000, 000, 000, 199, 193, 000, 000, 201, 065,
        000, 000, 000, 000, 000, 000, 199, 193, 000, 000, 198, 193, 000, 000, 000, 000,
        000, 000, 200, 065, 000, 000, 201, 065, 000, 000, 000, 000, 000, 000, 200, 065,
        000, 000, 198, 193, 078, 082, 077, 083, 004, 000, 000, 000, 000, 000, 128, 063,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 128, 063, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 128, 063, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 128, 063, 000, 000, 000, 000, 000, 000, 000, 000, 080, 084, 089, 080,
        001, 000, 000, 000, 004, 000, 000, 000, 080, 067, 078, 084, 001, 000, 000, 000,
        006, 000, 000, 000, 080, 086, 084, 088, 006, 000, 000, 000, 000, 000, 001, 000,
        002, 000, 003, 000, 002, 000, 001, 000, 071, 078, 068, 088, 004, 000, 000, 000,
        000, 000, 000, 000, 077, 084, 071, 067, 001, 000, 000, 000, 002, 000, 000, 000,
        077, 065, 084, 083, 002, 000, 000, 000, 000, 000, 000, 000, 001, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 092, 017, 141, 066,
        000, 000, 000, 000, 000, 000, 199, 193, 000, 000, 198, 193, 000, 000, 000, 000,
        000, 000, 200, 065, 000, 000, 201, 065, 003, 000, 000, 000, 092, 017, 141, 066,
        000, 000, 000, 000, 000, 000, 199, 193, 000, 000, 198, 193, 000, 000, 000, 000,
        000, 000, 200, 065, 000, 000, 201, 065, 092, 017, 141, 066, 000, 000, 000, 000,
        000, 000, 199, 193, 000, 000, 198, 193, 000, 000, 000, 000, 000, 000, 200, 065,
        000, 000, 201, 065, 092, 017, 141, 066, 000, 000, 000, 000, 000, 000, 199, 193,
        000, 000, 198, 193, 000, 000, 000, 000, 000, 000, 200, 065, 000, 000, 201, 065,
        085, 086, 065, 083, 001, 000, 000, 000, 085, 086, 066, 083, 004, 000, 000, 000,
        000, 000, 242, 062, 000, 000, 242, 062, 000, 000, 242, 062, 000, 000, 006, 063,
        000, 000, 006, 063, 000, 000, 242, 062, 000, 000, 006, 063, 000, 000, 006, 063,
        071, 069, 079, 065, 052, 000, 000, 000, 052, 000, 000, 000, 000, 000, 128, 063,
        000, 000, 000, 000, 000, 000, 128, 063, 000, 000, 128, 063, 000, 000, 128, 063,
        000, 000, 000, 000, 075, 071, 065, 079, 001, 000, 000, 000, 000, 000, 000, 000,
        255, 255, 255, 255, 187, 007, 000, 000, 000, 000, 000, 000, 066, 079, 078, 069,
        088, 001, 000, 000, 232, 000, 000, 000, 080, 108, 097, 110, 101, 048, 049, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 002, 000, 000, 000,
        008, 001, 000, 000, 075, 071, 083, 067, 003, 000, 000, 000, 003, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 128, 063, 000, 000, 128, 063,
        000, 000, 128, 063, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 177, 063, 000, 000, 177, 063, 000, 000, 177, 063, 100, 000, 000, 000,
        000, 000, 060, 063, 000, 000, 060, 063, 000, 000, 060, 063, 000, 000, 074, 063,
        000, 000, 074, 063, 000, 000, 074, 063, 000, 000, 079, 063, 000, 000, 079, 063,
        000, 000, 079, 063, 233, 000, 000, 000, 000, 000, 128, 063, 000, 000, 128, 063,
        000, 000, 128, 063, 000, 000, 193, 063, 000, 000, 193, 063, 000, 000, 193, 063,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 096, 000, 000, 000, 085, 078, 078, 065, 077, 069, 068, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 001, 000, 000, 000, 003, 000, 000, 000,
        008, 001, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 080, 073, 086, 084,
        048, 000, 000, 000, 000, 000, 000, 000, 002, 250, 152, 060, 084, 116, 068, 062,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 080, 082, 069, 050, 087, 001, 000, 000, 087, 001, 000, 000,
        096, 000, 000, 000, 066, 108, 105, 122, 080, 097, 114, 116, 105, 099, 108, 101,
        115, 116, 097, 110, 100, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 002, 000, 000, 000, 001, 000, 000, 000, 000, 144, 012, 000,
        000, 000, 152, 066, 000, 000, 000, 000, 000, 000, 052, 067, 000, 000, 000, 000,
        205, 204, 204, 062, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        001, 000, 000, 000, 001, 000, 000, 000, 001, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 128, 063, 154, 153, 153, 062, 251, 249, 121, 063, 162, 161, 033, 063,
        161, 160, 160, 061, 241, 239, 111, 063, 161, 160, 160, 061, 161, 160, 160, 061,
        248, 246, 118, 063, 161, 160, 160, 061, 161, 160, 160, 061, 255, 255, 000, 000,
        000, 184, 065, 000, 000, 064, 065, 102, 102, 230, 064, 000, 000, 000, 000, 000,
        000, 000, 000, 001, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 001,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 001, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 001, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 075, 080, 050, 069, 004,
        000, 000, 000, 000, 000, 000, 000, 255, 255, 255, 255, 000, 000, 000, 000, 000,
        000, 000, 000, 077, 001, 000, 000, 000, 000, 000, 000, 078, 001, 000, 000, 107,
        011, 094, 093, 134, 002, 000, 000, 000, 000, 000, 000, 075, 080, 050, 086, 001,
        000, 000, 000, 000, 000, 000, 000, 255, 255, 255, 255, 187, 007, 000, 000, 000,
        000, 000, 000, 082, 073, 066, 066, 200, 000, 000, 000, 200, 000, 000, 000, 096,
        000, 000, 000, 085, 078, 078, 065, 077, 069, 068, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 003, 000, 000, 000, 255, 255, 255, 255, 000, 064, 000, 000, 183,
        067, 186, 081, 183, 067, 186, 081, 000, 000, 128, 063, 000, 000, 128, 063, 000,
        000, 128, 063, 000, 000, 128, 063, 183, 067, 186, 081, 000, 000, 000, 000, 000,
        224, 118, 072, 015, 039, 000, 000, 015, 039, 000, 000, 000, 000, 000, 000, 183,
        067, 186, 081, 075, 082, 086, 083, 004, 000, 000, 000, 001, 000, 000, 000, 255,
        255, 255, 255, 000, 000, 000, 000, 000, 000, 000, 000, 077, 001, 000, 000, 000,
        000, 000, 000, 078, 001, 000, 000, 000, 000, 128, 063, 134, 002, 000, 000, 000,
        000, 000, 000, 067, 065, 077, 083, 120, 000, 000, 000, 120, 000, 000, 000, 067,
        097, 109, 101, 114, 097, 048, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
        000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 096,
        118, 063, 065, 125, 121, 251, 064, 226, 117, 150, 064, 216, 015, 073, 063, 000,
        064, 028, 070, 000, 000, 128, 063, 000, 000, 000, 000, 251, 093, 152, 060, 056,
        103, 068, 062
    ]]
?>
########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########
//TESH.scrollpos=106
//TESH.alwaysfold=0
library AIlibrary initializer Init needs baseLibrary

    void Debug(string s){
        BJDebugMsg("<AI.Debug>"+s)
    }

    //AI结构体
    struct AI

        //哈希表
        private static hashtable HT = InitHashtable()

        //哈希表索引
        private static int STRUCT = 1

        //注册英雄类型
        static int typeCount = 38 //英雄类型数量
        static int type[] //英雄类型ID
        static void initType() //注册英雄类型,在全局变量 Hero 设置后调用
        {
            int i = 1
            loop
                exitwhen i > typeCount
                type[i] = GetUnitTypeId(udg_hero[i])
                i++
            endloop
        }

        //是否是第一次启动AI
        static bool first = true

        //AI设置
        real homeX
        real homeY

        void setHomePoint(real x, real y) //设置AI的家的坐标,用于保护基地
        {
            homeX = x
            homeY = y
        }

        real restX
        real restY

        void setRestPoint(real x, real y) //设置AI的休息坐标,用于温泉边回血
        {
            restX = x
            restY = y
        }

        unit home
        void setHome(unit u) //设置AI的基地
        {
            home = u
        }

        real wayPointX[10]
        real wayPointY[10]
        void setWayPoint(int i, real x, real y) //设置AI的分路路径点.1=上路,2=下路,3=打野
        {
            if i > 10
                Debug("路径点编号不能大于10")
                return
            endif
            wayPointX[i] = x
            wayPointY[i] = y
        }

        //创建AI
        unit who //对应的英雄
        int id //英雄的单位类型[1-38]

        static AI create(unit u) //注册AI
        {
            int this = AI.allocate() //创建结构体
            who = u
            player p = GetOwningPlayer(u)
            int tid = GetPlayerTeam(p)

            if first //如果是首次开启AI,那么注册物编数据
                first = false
                //object.saveData()
            endif

            //注册一些数据
            if tid == 0 //万物复苏方
                setHomePoint(-5437, -6336)
                setRestPoint(-6543, -6776)
                setHome(gg_unit_hcas_0015)
            elseif tid == 1 //极冻酷寒
                setHomePoint(5575, 5720)
                setRestPoint(6233, 6262)
                setHome(gg_unit_e05G_0101)
            endif

            SaveInteger(HT, STRUCT, H2I(u), this) //将结构体索引保存在哈希表中,这样可以通过英雄来找到AI

            //找到该英雄的编号
            int i = 1
            loop
                exitwhen i > typeCount
                if GetUnitTypeId(u) == type[i]
                    id = i
                    exitwhen true
                endif
                i++
            endloop

            debug@ Debug("AI注册成功,英雄编号为"+I2S(id)+",AI索引为"+I2S(this))
            p = null
            return this
        }

        static AI get(unit u) //根据英雄找到该英雄的AI
        {
            return LoadInteger(HT, STRUCT, H2I(u))
        }

        void destroy() //移除AI
        {
            RemoveSavedInteger(HT, STRUCT, H2I(who)) //将结构体索引从哈希表中删除
            deallocate() //摧毁结构体
        }

        static void check_AI(){
            bool flag = true
            int i = 0
            loop
                exitwhen i > 9
                if GetPlayerController(Player(i)) == MAP_CONTROL_COMPUTER and (udg_player[i + 1] == null or get(udg_player[i + 1]) == 0) then
                    flag = false
                    if udg_player[i + 1] != null then
                        AI.create(udg_player[i + 1])
                    endif
                endif
                i ++
            endloop
            if flag then
                DestroyTimer(GetExpiredTimer())
                debug@ Debug("启用AI")
            endif
        }

        static void Init(){
            debug@ Debug("开启AI")
            TimerStart(CreateTimer(), 3, true, function AI.check_AI)
        }

    endstruct

    private void Init(){
    }
endlibrary
########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########

########
########
//TESH.scrollpos=-1
//TESH.alwaysfold=0
<?
    update('war3mapskin.txt',
        function(content)
            local new_lines = {
                {'[FrameDef]', 'CHAT_RECIPIENT_ALLIES', ' '},
                {'[FrameDef]', 'CHAT_RECIPIENT_ALL', '[全体BAKA]'},
                {'[FrameDef]', 'CHAT_RECIPIENT_PRIVATE', '[悄悄话]'},
                {'[FrameDef]', 'CHAT_RECIPIENT_OBSERVERS', '[围观群众]'},
                {'[FrameDef]', 'LOADING_WAITING_FOR_PLAYERS', '等待其他小霸王'}
            }

            local lines = {
                [''] = {}
            }

            for _, line in ipairs(new_lines) do
                local type, name, value = line[1], line[2], line[3]
                if not lines[type] then
                    lines[type] = {}
                    table.insert(lines, type)
                end
                table.insert(lines[type], {name, value})
                lines[name] = true
            end

            local type = ''
            for line in content:gmatch('%C+') do
                if line:sub(1, 1) == '[' and line:sub(-1, -1) == ']' then
                    type = line
                    if not lines[type] then
                        lines[type] = {}
                        table.insert(lines, type)
                    end
                else
                    local n = line:find('=')
                    if n then
                        local name = line:sub(1, n - 1)
                        local value = line:sub(n + 1, -1)
                        if not lines[name] then
                            table.insert(lines[type], {name, value})
                            lines[name] = true
                        end
                    end
                end
            end

            local new_lines = {}

            for _, type in ipairs(lines) do
                table.insert(new_lines, type)
                for _, line in ipairs(lines[type]) do
                    local name, value = line[1], line[2]
                    table.insert(new_lines, ('%s=%s'):format(name, value))
                end
                table.insert(new_lines, '\r\n')
            end

            return table.concat(new_lines, '\r\n')
        end
    )
?>
########
########
//TESH.scrollpos=-1
//TESH.alwaysfold=0
<?
    update('war3map.j',
        function(content)
            content = content:gsub('StringHash%(%s-%"(.-)%"%s-%)',
                function(s)
                    if not s:match('"') then
                        return string_hash(s)
                    end
                end
            )

            return content
        end
    )

?>
########
########
//TESH.scrollpos=733
//TESH.alwaysfold=0

<?
    --优化逆天
    --local update = function() end
    update('war3map.j',
        function(content)
            local time = {}
            time[0] = os.clock()

            local function getType(type)
                if type:sub(-6) == 'Handle' then
                    type = type:sub(1, -7):lower()
                elseif type == 'Str' then
                    type = 'string'
                else
                    type = type:lower()
                end
                return type
            end

            local function getType2(type)
                if type == 'string' then
                    type = 'str'
                elseif type == 'fogmodifier' then
                    type = 'fogModifierHandle'
                elseif type == 'texttag' then
                    type = 'textTagHandle'
                elseif type ~= 'integer' and type ~= 'boolean' and type ~= 'real' then
                    type = type .. 'Handle'
                end
                type = type:sub(1, 1):upper() .. type:sub(2)
                return type
            end

            local function getTypeValue(type)
                local value
                if type == 'boolean' then
                    value = 'false'
                elseif type == 'integer' then
                    value = '0'
                elseif type == 'real' then
                    value = '0.'
                elseif type == 'string' then
                    value = '""'
                else
                    value = 'null'
                end
                return value
            end

            local function autoFlush(type)
                return type == 'string' or type == 'boolean' or type == 'integer' or type == 'real'
            end

            local globalList = {}

            local function addGlobal(name, type, value)
                if not globalList[name] then
                    table.insert(globalList, name)
                    globalList[name] = {type, value}
                end
            end

            addGlobal('ydg_index', 'integer', 0)

                --io.save(fs.ydwe_path() / "logs" / "script_lua.j", content)

                    local funcs = {}

                    content = content:gsub('function (%S+)( takes%C+)(.-)endfunction',
                        function(name, l, s)
                            funcs[name] = {
                                name = name, --名字
                                l = l, --参数
                                s = s, --代码
                                locals = {}, --存放局部变量
                                para_locals = {}, --存放父函数当前的局部变量状态(也就是当前函数可以继承到的变量)
                                need_locals = {}, --存放选取时,子函数的局部变量状态
                                type = {}, --函数的逆天类型(局部/计时器/触发器/选取)
                            }

                            table.insert(funcs, name)
                            return '__THIS_IS_FUNCTION__' .. name .. '__FUNCTION_END__'
                        end
                    )

                    local sys_local_var = {
                        ydl_trigger = true,
                        ydl_trigger_handle = true,
                        ydl_timer = true,
                        ydl_timer_handle = true,
                        ydl_exp_timer_handle = true,
                        ydl_tri_trigger_handle = true,
                    }

                    --对逆天局部变量进行初步优化

                    local function loadFunction(name)
                        local t = funcs[name]
                        if t.loaded then
                            return
                        end

                        t.loaded = true

                        --添加局部变量
                        local function addLocal(name, type, value, i)
                            if not t.locals[name] then
                                if not type then
                                    type = name:match('ydl_(%a+)')
                                end
                                t.locals[name] = {
                                    type,   --类型
                                    value,  --初始值
                                    --fresh,  --更新函数
                                }
                                if i then
                                    table.insert(t.locals, i, name)
                                else
                                    table.insert(t.locals, name)
                                end
                            end
                        end

                        --设置局部变量
                        local function setLocal(name, flag)
                            if flag then
                                t.locals[name].set = t.locals[name].set - 1
                                if t.locals[name].set == 0 then
                                    t.locals[name].set = nil
                                end
                            else
                                t.locals[name].set = (t.locals[name].set or 0) + 1
                            end

                        end

                        --读取局部变量
                        local function getLocal(name, flag)
                            if flag then
                                t.locals[name].get = t.locals[name].get - 1
                                if t.locals[name].get == 0 then
                                    t.locals[name].get = nil
                                end
                            else
                                t.locals[name].get = (t.locals[name].get or 0) + 1
                            end

                        end

                        --保存临时局部变量(直接写在逆天计时器/触发器参数里的)
                        local function saveLocal(name, type, value)
                            t.saves[name] = {type, value}
                        end

                        --return的标记
                        local returnData = {}

                        local function returnMark()
                            local data = {}
                            table.insert(returnData, data)

                            --保存当前的局部变量状态
                            for i, name in ipairs(t.locals) do
                                data[i] = name
                                if not data[name] then
                                    data[name] = {}
                                end
                                for k, v in pairs(t.locals[name]) do
                                    data[name][k] = v
                                end
                            end

                            return '@@return_' .. #returnData
                        end

                        --设置局部变量初始值
                        local function setLocalValue(name, value)
                            local v = t.locals[name]
                            local funcs = {
                                _timer = function()
                                    local vtype = getType2(v[1])
                                    local key = name:match('ydl_%a+_(%w+)')
                                    value = ('Load%s(YDHT, ydl_exp_timer_handle, %s)'):format(vtype, key)
                                    addLocal('ydl_exp_timer_handle', 'integer', 'GetHandleId(GetExpiredTimer())', 1)
                                    setLocal('ydl_exp_timer_handle')
                                end,
                                _trigger = function()
                                    local vtype = getType2(v[1])
                                    local key = name:match('ydl_%a+_(%w+)')
                                    value = ('Load%s(YDHT, ydl_tri_trigger_handle, %s)'):format(vtype, key)
                                    addLocal('ydl_tri_trigger_handle', 'integer', 'GetHandleId(GetTriggeringTrigger())', 1)
                                    setLocal('ydl_tri_trigger_handle')
                                end,
                            }
                            v[2] = funcs[value] and funcs[value]() or value
                            --赋初始值后视为设置(但不需要刷新状态)
                            setLocal(name)

                            --遍历return,进行局部变量状态设置
                            for i, data in ipairs(returnData) do
                                if not data[name] then
                                    data[name] = {}
                                end
                                data[name].set = true
                            end
                        end

                        --设置局部变量更新状态
                        local function setLocalFresh(name, value)
                            local v = t.locals[name]
                            local funcs = {
                                _timer = function()
                                    local vtype = getType2(v[1])
                                    local key = name:match('ydl_%a+_(%w+)')
                                    value = ('call Save%s(YDHT, ydl_exp_timer_handle, %s, %s)'):format(vtype, key, name)
                                    addLocal('ydl_exp_timer_handle', 'integer', 'GetHandleId(GetExpiredTimer())', 1)
                                    setLocal('ydl_exp_timer_handle')
                                end,
                                _trigger = function()
                                local vtype = getType2(v[1])
                                    local key = name:match('ydl_%a+_(%w+)')
                                    value = ('call Save%s(YDHT, ydl_tri_trigger_handle, %s, %s)'):format(vtype, key, name)
                                    addLocal('ydl_tri_trigger_handle', 'integer', 'GetHandleId(GetTriggeringTrigger())', 1)
                                    setLocal('ydl_tri_trigger_handle')
                                end,
                            }
                            v[3] = funcs[value] and funcs[value]() or value
                        end

                        --loop的标记
                        local loop_level = 0
                        local loop_start = 0

                        local function loopMark()
                            loop_level = loop_level + 1
                            if loop_level == 1 then

                                loop_start = #returnData + 1 --用来记录嵌套在loop中的return,以便正确保存数据
                            end
                        end

                        local function endloopMark()
                            loop_level = loop_level - 1
                            if loop_level == 0 then
                                local loop_end = #returnData
                                for i = loop_start, loop_end do
                                    local data = returnData[i]
                                    --保存当前的局部变量状态
                                    for i, name in ipairs(t.locals) do
                                        data[i] = name
                                        data[name] = {}
                                        for k, v in pairs(t.locals[name]) do
                                            data[name][k] = v
                                        end
                                    end
                                end
                            end
                        end

                        --更新局部变量(只更新到目前为止赋值过的局部变量)
                        local function freshLocal(i)
                            local fresh = {}
                            local t = i and returnData[i] or t.locals
                            for _, name in ipairs(t) do
                                local v = t[name]

                                --检查是否需要更新状态
                                if v[3] then
                                    table.insert(fresh, v[3])
                                end
                            end
                            return table.concat(fresh, '\n') .. '\n'
                        end

                        --释放局部变量
                        local function flushLocal(i)
                            local flush = {}
                            local t2 = i and returnData[i] or t.locals
                            for _, name in ipairs(t.locals) do
                                local v = t.locals[name]
                                local type = v[1]
                                --检查是否需要释放
                                if t2[name] and t2[name].set and not autoFlush(type) and not sys_local_var[name] then
                                    table.insert(flush, ('set %s = null'):format(name))
                                end
                            end
                            return table.concat(flush, '\n') .. '\n'
                        end

                        --向子函数保存当前局部变量状态
                        local function saveParaLocal(name)
                            local tt = funcs[name].para_locals

                            for name, v in pairs(t.locals) do
                                if v.set then
                                    tt[name] = v
                                end
                            end

                            for name, v in pairs(t.para_locals) do
                                tt[name] = v
                            end

                            if t.saves then
                                for name, v in pairs(t.saves) do
                                    tt[name] = v
                                end
                            end
                        end

                        --设置为子函数
                        local function setPara(name)
                            funcs[name].para = t.name
                        end

                        t.s = t.s:gsub('[^\n\r]+',
                            function(line)
                                if line:match('local integer ydl_localvar_step') then
                                    --带有逆天局部变量的主函数
                                    t.type['局部'] = true
                                    return ''
                                end

                                line = line:gsub('LoadInteger%(YDHT, GetHandleId%(GetTriggeringTrigger%(%)%), 0xECE825E7%)',
                                    function()
                                        t.type['局部'] = true
                                        return 'ydl_localvar_step'
                                    end
                                )

                                if line:match('return') then
                                    return returnMark(line) .. '\n' .. line
                                end

                                if line:match('endloop') then
                                    return endloopMark()
                                end

                                if line:match('loop') then
                                    return loopMark()
                                end

                                --新建逆天计时器
                                if line:match('local timer ydl_timer') then
                                    t.saves = {}
                                    return line .. '\nlocal integer ydl_timer_handle'
                                end

                                line = line:gsub('GetHandleId%(ydl_timer%)',
                                    function()
                                        return 'ydl_timer_handle'
                                    end
                                )

                                line = line:gsub('set ydl_timer = (.+)',
                                    function(value)
                                        if value == 'null' then
                                            return
                                        end
                                        if value == 'GetExpiredTimer()' then
                                            --如果直接拿到期计时器做新的逆天触发器,则保护该地址
                                            line = 'ydl_exp_timer_handle = 0\n' .. line
                                        end
                                        return line .. '\nset ydl_timer_handle = GetHandleId(ydl_timer)'
                                    end
                                )

                                --新建逆天触发器
                                if line:match('local trigger ydl_trigger') then
                                    t.saves = {}
                                    return line .. '\nlocal integer ydl_trigger_handle'
                                end

                                line = line:gsub('GetHandleId%(ydl_trigger%)',
                                    function()
                                        return 'ydl_trigger_handle'
                                    end
                                )

                                if line:match('set ydl_trigger = [^n][^u][^l][^l]') then
                                    line = line .. '\nset ydl_trigger_handle = GetHandleId(ydl_trigger)'
                                end

                                --查找子函数
                                local fname = line:match('function ([%w_]+)')
                                if fname then
                                    local tt = funcs[fname]
                                    if tt then
                                        setPara(fname)
                                        if line:match('call [%w%_%.]-TimerStart%(ydl_timer') then
                                            --逆天计时器子函数
                                            tt.type['计时器'] = true
                                            tt.type['选取'] = false
                                            saveParaLocal(fname)
                                        end
                                        if line:match('call TriggerAddCondition%(ydl_trigger') then
                                            --逆天触发器子函数
                                            tt.type['触发器'] = true
                                            tt.type['选取'] = false
                                            saveParaLocal(fname)
                                        end
                                        if line:match('call ForGroup') or line:match('EnumDestructables') then
                                            --选取单位组子函数
                                            tt.type['选取'] = true
                                            tt.type['计时器'] = t.type['计时器']
                                            tt.type['触发器'] = t.type['触发器']
                                            loadFunction(fname)
                                            local set = {}
                                            local get = {}
                                            for i, name in ipairs(tt.need_locals) do
                                                if tt.need_locals[name].get then
                                                    table.insert(get, ('set %s[ydg_index] = %s'):format(name:gsub('ydl', 'ydg'), name))
                                                    get[name] = true

                                                    --检查是否继承父函数状态
                                                    addLocal(name)
                                                    getLocal(name)
                                                    if t.para_locals[name] then
                                                        if t.type['计时器'] then
                                                            setLocalValue(name, '_timer')
                                                        end
                                                        if t.type['触发器'] then
                                                            setLocalValue(name, '_trigger')
                                                        end
                                                    end

                                                end
                                                if tt.need_locals[name].set then
                                                    table.insert(set, ('set %s = %s[ydg_index]'):format(name, name:gsub('ydl', 'ydg')))
                                                    --即使只赋值,也要赋一个初始值给他
                                                    if not get[name] then
                                                        table.insert(get, ('set %s[ydg_index] = %s'):format(name:gsub('ydl', 'ydg'), name))
                                                    end

                                                    --检查是否继承父函数状态
                                                    addLocal(name)
                                                    setLocal(name)
                                                    if t.para_locals[name] then
                                                        if t.type['计时器'] then
                                                            setLocalFresh(name, '_timer')
                                                        end
                                                        if t.type['触发器'] then
                                                            setLocalFresh(name, '_trigger')
                                                        end
                                                    end

                                                end
                                            end
                                            if not t.type['选取'] and (#set > 0 or #get > 0) then
                                                line = table.concat(
                                                    {
                                                        'set ydg_index = ydg_index + 1',
                                                        table.concat(get, '\n'),
                                                        line,
                                                        table.concat(set, '\n'),
                                                        'set ydg_index = ydg_index - 1'
                                                    },
                                                '\n')
                                            end
                                        end
                                    end
                                end

                                if line:match('set ydl_localvar_step') then
                                    return ''
                                end
                                if line:sub(-18, -1) == 'ydl_localvar_step)' then
                                    return ''
                                end

                                if t.type['局部'] then
                                    line = line:gsub('Load(%a+)%(YDHT, GetHandleId%(GetTriggeringTrigger%(%)%)%*ydl_localvar_step, (%w+)%)',
                                        function(vtype, key)
                                            local type = getType(vtype)
                                            local name = ('ydl_%s_%s'):format(type, key)
                                            addLocal(name)
                                            getLocal(name)

                                            if t.type['选取'] then
                                                name = ('ydg_%s_%s[ydg_index]'):format(type, key)
                                            end

                                            return name
                                        end
                                    )

                                    local vtype, key, value = line:match('call Save(%a+)%(YDHT, GetHandleId%(GetTriggeringTrigger%(%)%)%*ydl_localvar_step, (%w+), (.+)%)')
                                    if vtype then
                                        local type = getType(vtype)
                                        local name = ('ydl_%s_%s'):format(type, key)
                                        addLocal(name)
                                        setLocal(name)

                                        if t.type['选取'] then
                                            name = ('ydg_%s_%s[ydg_index]'):format(type, key)
                                        end

                                        line = ('set %s = %s'):format(name, value)
                                    end
                                end

                                if t.type['计时器'] then
                                    line = line:gsub('Load(%a+)%(YDHT, GetHandleId%(GetExpiredTimer%(%)%)%, (%w+)%)',
                                        function(vtype, key)
                                            local type = getType(vtype)
                                            local name = ('ydl_%s_%s'):format(type, key)
                                            addLocal(name)
                                            getLocal(name)

                                            --检查是否继承父函数状态
                                            if t.para_locals[name] then
                                                setLocalValue(name, '_timer')
                                            end

                                            if t.type['选取'] then
                                                name = ('ydg_%s_%s[ydg_index]'):format(type, key)
                                            end

                                            return name
                                        end
                                    )

                                    local vtype, key, value = line:match('call Save(%a+)%(YDHT, GetHandleId%(GetExpiredTimer%(%)%)%, (%w+), (.+)%)')
                                    if vtype then
                                        local type = getType(vtype)
                                        local name = ('ydl_%s_%s'):format(type, key)
                                        addLocal(name)
                                        setLocal(name)

                                        --检查是否继承父函数状态
                                        if t.para_locals[name] then
                                            setLocalFresh(name, '_timer')
                                        end

                                        if t.type['选取'] then
                                            name = ('ydg_%s_%s[ydg_index]'):format(type, key)
                                        end

                                        if value == 'null' then
                                            line = ('call RemoveSavedHandle(YDHT, ydl_exp_timer_handle, %s)\nset %s = %s'):format(key, name, value)
                                        else
                                            line = ('set %s = %s'):format(name, value)
                                        end
                                    end

                                    --检查是否在选取中对到期的计时器地址有需求
                                    if t.type['选取'] and line:match('ydl_exp_timer_handle') then
                                        addLocal('ydl_exp_timer_handle', 'integer', 'GetHandleId(GetExpiredTimer())')
                                        setLocal('ydl_exp_timer_handle')
                                    end

                                    if line:match('call FlushChildHashtable%(YDHT, GetHandleId%(GetExpiredTimer%(%)%)%)') then
                                        addLocal('ydl_exp_timer_handle', 'integer', 'GetHandleId(GetExpiredTimer())')
                                        setLocal('ydl_exp_timer_handle')
                                        return 'call FlushChildHashtable(YDHT, ydl_exp_timer_handle)\nset ydl_exp_timer_handle = 0'
                                    end

                                end

                                if t.type['触发器'] then

                                    line = line:gsub('Load(%a+)%(YDHT, GetHandleId%(GetTriggeringTrigger%(%)%)%, (%w+)%)',
                                        function(vtype, key)
                                            local type = getType(vtype)
                                            local name = ('ydl_%s_%s'):format(type, key)
                                            addLocal(name)
                                            getLocal(name)

                                            --检查是否继承父函数状态
                                            if t.para_locals[name] then
                                                setLocalValue(name, '_trigger')
                                            end
                                            if t.type['选取'] then
                                                name = ('ydg_%s_%s[ydg_index]'):format(type, key)
                                            end

                                            return name
                                        end
                                    )

                                    local vtype, key, value = line:match('call Save(%a+)%(YDHT, GetHandleId%(GetTriggeringTrigger%(%)%)%, (%w+), (.+)%)')
                                    if vtype then
                                        local type = getType(vtype)
                                        local name = ('ydl_%s_%s'):format(type, key)
                                        addLocal(name)
                                        setLocal(name)

                                        --检查是否继承父函数状态
                                        if t.para_locals[name] then
                                            setLocalFresh(name, '_trigger')
                                        end
                                        if t.type['选取'] then
                                            name = ('ydg_%s_%s[ydg_index]'):format(type, key)
                                        end

                                        if value == 'null' then
                                            line = ('call RemoveSavedHandle(YDHT, ydl_tri_trigger_handle, %s)\nset %s = %s'):format(key, name, value)
                                        else
                                            line = ('set %s = %s'):format(name, value)
                                        end

                                    end

                                    --检查是否在选取中对触发的触发器地址有需求
                                    if t.type['选取'] and line:match('ydl_tri_trigger_handle') then
                                        addLocal('ydl_tri_trigger_handle', 'integer', 'GetHandleId(GetTriggeringTrigger())')
                                        setLocal('ydl_tri_trigger_handle')
                                    end

                                    if line:match('call FlushChildHashtable%(YDHT, GetHandleId%(GetTriggeringTrigger%(%)%)%)') then
                                        addLocal('ydl_tri_trigger_handle', 'integer', 'GetHandleId(GetTriggeringTrigger())')
                                        setLocal('ydl_tri_trigger_handle')
                                        return 'call FlushChildHashtable(YDHT, ydl_tri_trigger_handle)\nset ydl_tri_trigger_handle = 0'
                                    end

                                end

                                --检查新建逆天计时器的冗余代码
                                local vtype, key, value = line:match('call Save(%a+)%(YDHT, ydl_timer_handle, (%w+), (.+)%)')
                                if vtype then
                                    local type = getType(vtype)
                                    local name = ('ydl_%s_%s'):format(type, key)
                                    if name == value then
                                        --正在保存变量本身
                                        if not t.locals[name].set then
                                            getLocal(name, true)
                                            return ''
                                        end
                                    else
                                        saveLocal(name, type, value)
                                    end
                                end

                                --检查新建逆天触发器的冗余代码
                                local vtype, key, value = line:match('call Save(%a+)%(YDHT, ydl_trigger_handle, (%w+), (.+)%)')
                                if vtype then
                                    local type = getType(vtype)
                                    local name = ('ydl_%s_%s'):format(type, key)
                                    if name == value then
                                        --正在保存变量本身
                                        if not t.locals[name].set then
                                            getLocal(name, true)
                                            return ''
                                        end
                                    else
                                        saveLocal(name, type, value)
                                    end
                                end


                                return line
                            end
                        )

                        --修改return
                        t.s = t.s:gsub('@@return_(%d+)',
                            function(i)
                                i = tonumber(i)
                                if not t.type['选取'] then
                                    return freshLocal(i) .. flushLocal(i)
                                else
                                    return ''
                                end
                            end
                        )
                        if not t.type['选取'] then
                            --在函数尾部更新局部变量
                            t.s = t.s .. freshLocal()

                            --在函数尾部释放局部变量
                            t.s = t.s .. flushLocal()
                        end

                        --生成局部变量
                        local loc_define = {}
                        for _, name in ipairs(t.locals) do
                            local v = t.locals[name]
                            if v.set or v.get then
                                local type = v[1]
                                if t.type['选取'] and not sys_local_var[name] then
                                    addGlobal(name:gsub('ydl', 'ydg'), type, 'array')
                                    if not t.need_locals[name] then
                                        table.insert(t.need_locals, name)
                                        local tt = {}
                                        t.need_locals[name] = tt
                                        for k, v in pairs(v) do
                                            tt[k] = v
                                        end
                                    end
                                else
                                    local value = v[2] or getTypeValue(type)
                                    local line = ('local %s %s = %s'):format(type, name, value)
                                    table.insert(loc_define, line)
                                end
                            end
                        end

                        --在函数顶部声明局部变量
                        t.s = table.concat(loc_define, '\n') .. t.s
                    end

                    --遍历
                    for i = #funcs, 1, -1 do
                        local name = funcs[i]
                        loadFunction(name)
                    end

                    content = content:gsub('__THIS_IS_FUNCTION__([%w_]+)__FUNCTION_END__',
                        function(name)
                            if name and funcs[name] then
                                return 'function ' .. name .. funcs[name].l .. '\n' .. funcs[name].s .. '\nendfunction'
                            end
                        end
                    )

                    --静态全局变量

                    local event_key = string_hash '事件'
                    local event_key2    = string_hash '事件返回'

                    content = content:gsub('Load(%a+)%(YDHT, (0x%w+), (0x%w+)%)',
                        function(vtype, k1, k2)
                            local type = getType(vtype)
                            local name = ('ydg_%s_%s_%s'):format(type, k1, k2)

                            --对事件变量进行特例
                            if k1 == event_key then
                                addGlobal(name, type, 'array')
                                return name .. '[Event.index]'
                            elseif k1 == event_key2 then
                                name = ('ydg_%s_%s_%s'):format(type, event_key, k2)
                                addGlobal(name, type, 'array')
                                return name .. '[Event.index + 1]'
                            else
                                addGlobal(name, type, getTypeValue(type))
                                return name
                            end
                        end
                    )

                    content = content:gsub('call Save(%a+)%(YDHT, (0x%w+), (0x%w+), (%C+)%)',
                        function(vtype, k1, k2, v)
                            local type = getType(vtype)
                            local name = ('ydg_%s_%s_%s'):format(type, k1, k2)

                            --对事件变量进行特例
                            if k1 == event_key then
                                addGlobal(name, type, 'array')
                                return ('set %s[Event.index + 1] = %s'):format(name, v)
                            elseif k1 == event_key2 then
                                name = ('ydg_%s_%s_%s'):format(type, event_key, k2)
                                addGlobal(name, type, 'array')
                                return ('set %s[Event.index] = %s'):format(name, v)
                            else
                                addGlobal(name, type, getTypeValue(type))
                                return ('set %s = %s'):format(name, v)
                            end
                        end
                    )

                    content = content:gsub('Save(%a+)%(YDHT, (0x%w+), (0x%w+), (%C+)%)',
                        function(vtype, k1, k2, v)
                            local type = getType(vtype)
                            local name = ('ydg_%s_%s_%s'):format(type, k1, k2)

                            --对事件变量进行特例
                            if k1 == event_key then
                                addGlobal(name, type, 'array')
                                return ('set %s[Event.index + 1] = %s'):format(name, v)
                            elseif k1 == event_key2 then
                                name = ('ydg_%s_%s_%s'):format(type, event_key, k2)
                                addGlobal(name, type, 'array')
                                return ('set %s[Event.index] = %s'):format(name, v)
                            else
                                addGlobal(name, type, getTypeValue(type))
                                return ('set %s = %s'):format(name, v)
                            end
                        end
                    )

                    io.save(fs.ydwe_path() / "logs" / "script_lua.j", content)

                time[1] = os.clock()


                addGlobal('MU_UPDATE_RESULT_1', 'string', ('"优化总用时:%.3f秒"'):format(time[1] - time[0]))

                --生成全局变量
                local function getGlobal()
                    local list = {}
                    for i, name in ipairs(globalList) do
                        local t = globalList[name]
                        local type, value = t[1], t[2]
                        if value == 'array' then
                            table.insert(list, ('%s array %s'):format(type, name))
                        else
                            table.insert(list, ('%s %s = %s'):format(type, name, value))
                        end
                    end
                    return table.concat(list, '\n')
                end

                content = content .. '\nglobals\n' .. getGlobal() .. '\nendglobals\n'


            return content
        end
    )

?>
########
########
//TESH.scrollpos=-1
//TESH.alwaysfold=0
<?
    --静态命令字符
    update('war3map.j',
        function(content)
            content = content:gsub('String2OrderIdBJ%(%s-%"(%a+)%"%s-%)',
                function(s)
                    return order2id[s]
                end
            )

            return content
        end
    )
?>
########
########
//TESH.scrollpos=-1
//TESH.alwaysfold=0
<?

    update('war3map.j',
        function(content)
            content = content:gsub('Save%a-Handle%((%C-), null%)',
                function(s)
                    return ('RemoveSavedHandle(%s)'):format(s)
                end
            )

            return content
        end
    )

?>

########
########
//TESH.scrollpos=-1
//TESH.alwaysfold=0
<?

    --修改版本号,在地图情节中设置版本号后自动修改其他几处
    ----游戏界面
    ----脚本中所有的__MAP_VER_NAME__标记
    update('war3map.j',
        function(content)
            local char_name = content:match([[SetMapName%( "TRIGSTR_(.-)" %)]])

            --版本号文本的字符串id
            local ver_name_id = tonumber(char_name)

            local name_id

            --寻找游戏界面中的文本
            update('war3mapskin.txt',
                function(txt)
                    name_id = tonumber(txt:match([[UPKEEP_NONE=TRIGSTR_(%d+)]]))
                end
            )

            local ver_name --保存版本号,例如"2.6H"

            --处理游戏界面
            update('war3map.wts',
                function(txt)
                    if ver_name_id then
                        ver_name = txt:match(([[STRING %d.-{.-(%%d%%.%%d.).-}]]):format(ver_name_id))
                    else
                        ver_name = content:match([[SetMapName%( ".-(%d%.%d.).-" %)]])
                    end

                    txt = txt:gsub(([[(STRING %d%%D-{%%c+)(.-)(%%c+})]]):format(name_id), ([[%%1%s%%3]]):format("|cff00ff00全明星战役|cffffff00" .. ver_name))

                    txt = txt:gsub('__MAP_VER_NAME__', ver_name)

                    return txt
                end
            )

            --修改地图中所有的__MAP_VER_NAME__标记
            content = content:gsub('__MAP_VER_NAME__', ver_name)

            return content

        end
    )

?>
########
########
//TESH.scrollpos=0
//TESH.alwaysfold=0
<?

    update('war3map.j',
        function(content)
            content = content:gsub('== true', '')
            content = content:gsub('else[%c%s]+endif', 'endif')

            return content
        end
    )

?>
########